<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>bucket.jl · Soil dynamics simulator</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Soil dynamics simulator</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">types.jl</a></li><li class="is-active"><a class="tocitem" href>bucket.jl</a></li><li><a class="tocitem" href="../body_soil/">body_soil.jl</a></li><li><a class="tocitem" href="../intersecting_cells/">intersecting_cells.jl</a></li><li><a class="tocitem" href="../relax/">relax.jl</a></li><li><a class="tocitem" href="../utils/">utils.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>bucket.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>bucket.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/main/docs/src/bucket.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation-for-bucket.jl"><a class="docs-heading-anchor" href="#Documentation-for-bucket.jl">Documentation for bucket.jl</a><a id="Documentation-for-bucket.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-for-bucket.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._calc_bucket_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, T}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_bucket_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, T}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_bucket_pos!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_bucket_pos!(
    out::SimOut{B,I,T}, pos::Vector{T}, ori::Quaternion{T}, grid::GridParam{I,T},
    bucket::BucketParam{I,T}, step_bucket_grid::T=0.5, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function determines all the cells where the bucket is located. The bucket position is calculated based on its reference pose stored in the <code>bucket</code> struct, as well as the provided position (<code>pos</code>) and orientation (<code>ori</code>). <code>pos</code> and <code>ori</code> are used to apply the appropriate translation and rotation to the bucket relative to its reference pose. The center of rotation is assumed to be the bucket origin. The orientation is provided using the quaternion definition.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>pos::Vector{Float64}</code>: Cartesian coordinates of the bucket origin. [m]</li><li><code>ori::Quaternion{Float64}</code>: Orientation of the bucket. [Quaternion]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li><li><code>step_bucket_grid::Float64</code>: Spatial increment used to decompose the edges of the bucket.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">pos = [0.5, 0.3, 0.4]
ori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)
grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_calc_bucket_pos!(out, pos, ori, grid, bucket)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/88a3d7cd0e931d58097508a3c26d34981e4c0772/src/bucket.jl#L9-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._calc_line_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, T, GridParam{I, T}}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_line_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, T, GridParam{I, T}}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_line_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_line_pos(
    a::Vector{T}, b::Vector{T}, delta::T, grid::GridParam{I,T}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function determines all the cells that lie on a straight line between two Cartesian coordinates.</p><p>For the sake of accuracy, the line is divided into smaller segments using a spatial increment <code>delta</code>.</p><p>The coordinates of each sub-point (ab_i) along the line can then be calculated as</p><pre><code class="nohighlight hljs">ab_i = a + ab * i * delta / norm(ab)</code></pre><p>where i is the increment number and ab = b - a. The Cartesian coordinates can then be converted into indices</p><pre><code class="nohighlight hljs">ab_i_ind = ab_i / cell_size + grid_half_length + 1</code></pre><p>Finally, the floating-point values are rounded to obtain the cell indices in the X, Y, Z directions. As the center of each cell is considered to be on the center of the top surface, <code>round</code> should be used for getting the cell indices in the X and Y direction, while <code>ceil</code> should be used for the Z direction.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>When the line follows a cell border, the exact location of the line becomes ambiguous. It is assumed that the caller resolves this ambiguity.</li></ul><p><strong>Inputs</strong></p><ul><li><code>a::Vector{Float64}</code>: Cartesian coordinates of the first extremity of the line. [m]</li><li><code>b::Vector{Float64}</code>: Cartesian coordinates of the second extremity of the line. [m]</li><li><code>delta::Float64</code>: Spatial increment used to decompose the line. [m]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li></ul><p><strong>Outputs</strong></p><ul><li><code>line_pos::Vector{Vector{Int64}}</code>: Collection of cells indices where the line is located.                                    Result is not sorted and duplicates should be expected.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
a = [1.0, 0.5, 0.7]
b = [0.7, 0.8, -0.3]

line_pos = _calc_line_pos(a, b, 0.01, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/88a3d7cd0e931d58097508a3c26d34981e4c0772/src/bucket.jl#L647-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._calc_rectangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_rectangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_rectangle_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_rectangle_pos(
    a::Vector{T}, b::Vector{T}, c::Vector{T}, d::Vector{T},
    delta::T, grid::GridParam{I,T}, tol::T=1e-8
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function determines the cells where a rectangle surface is located. The rectangle is defined by providing the Cartesian coordinates of its four vertices in the proper order.</p><p>To optimize performance, the function iterates over a portion of the horizontal grid where the rectangle is located. For each cell, the function calculates the height of the plane formed by the rectangle at the top right corner of the cell. If the cell is within the rectangle area, the calcualted height is added to the results for the four neighboring cells.</p><p>This method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.</p><p>However, this approach does not work when the rectangle is perpendicular to the XY plane. To handle this case, the function uses the <code>_calc_line_pos</code> function to include the cells that lie on the four edges of the rectangle.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.</li><li>Not all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.</li><li>When the rectangle follows a cell border, the exact location of the rectangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.</li></ul><p><strong>Inputs</strong></p><ul><li><code>a::Vector{Float64}</code>: Cartesian coordinates of one vertex of the rectangle. [m]</li><li><code>b::Vector{Float64}</code>: Cartesian coordinates of one vertex of the rectangle. [m]</li><li><code>c::Vector{Float64}</code>: Cartesian coordinates of one vertex of the rectangle. [m]</li><li><code>d::Vector{Float64}</code>: Cartesian coordinates of one vertex of the rectangle. [m]</li><li><code>delta::Float64</code>: Spatial increment used to decompose the edges of the rectangle. [m]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>: Collection of cells indices where the rectangle is located.                          Result is not sorted and duplicates may be present.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
a = [1.0, 0.0, 0.7]
b = [0.0, 1.0, 0.7]
c = [0.0, 1.0, 0.9]
d = [1.0, 0.0, 0.9]

rect_pos = _calc_rectangle_pos(a, b, c, d, 0.01, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/88a3d7cd0e931d58097508a3c26d34981e4c0772/src/bucket.jl#L125-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._calc_triangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_triangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_triangle_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_triangle_pos(
    a::Vector{T}, b::Vector{T}, c::Vector{T},
    delta::T, grid::GridParam{I,T}, tol::T=1e-8
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function determines the cells where a triangle surface is located. The triangle is defined by providing the Cartesian coordinates of its three vertices in the proper order.</p><p>To optimize performance, the function iterates over a portion of the horizontal grid where the triangle is located. For each cell, the function calculates the height of the plane formed by the triangle at the top right corner of the cell. If the cell is within the triangle area, the calcualted height is added to the results for the four neighboring cells.</p><p>This method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.</p><p>However, this approach does not work when the triangle is perpendicular to the XY plane. To handle this case, the function uses the <code>_calc_line_pos</code> function to include the cells that lie on the three edges of the triangle.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.</li><li>Not all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.</li><li>When the triangle follows a cell border, the exact location of the triangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.</li></ul><p><strong>Inputs</strong></p><ul><li><code>a::Vector{Float64}</code>: Cartesian coordinates of one vertex of the triangle. [m]</li><li><code>b::Vector{Float64}</code>: Cartesian coordinates of one vertex of the triangle. [m]</li><li><code>c::Vector{Float64}</code>: Cartesian coordinates of one vertex of the triangle. [m]</li><li><code>delta::Float64</code>: Spatial increment used to decompose the edges of the triangle. [m]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>: Collection of cells indices where the triangle is located.                          Result is not sorted and duplicates may be present.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
a = [1.0, 0.0, 0.7]
b = [0.0, 1.0, 0.7]
c = [0.0, 1.0, 0.9]

tri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/88a3d7cd0e931d58097508a3c26d34981e4c0772/src/bucket.jl#L388-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._decompose_vector_rectangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._decompose_vector_rectangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._decompose_vector_rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_decompose_vector_rectangle(
    ab_ind::Vector{T}, ad_ind::Vector{T}, a_ind::Vector{T},
    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function performs a vector decomposition on a portion of the horizontal plane where a rectangle ABCD is located. The position of the rectangle is defined by its edges AB and AD, while the specified area extends over [<code>area_min_x</code>, <code>area_min_x + area_length_x</code>] on the X direction and [<code>area_min_y</code>, <code>area_min_y + area_length_y</code>] on the Y direction.</p><p>For each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AD. Let O be the name of a cell, it can then be decomposed as</p><pre><code class="nohighlight hljs">AO = c_ab * AB + c_ad * AD.</code></pre><p>This decomposition leads to a system of 2 equations with 2 unknowns (c<em>ab and c</em>ad)</p><pre><code class="nohighlight hljs">AO[1] = c_ab * AB[1] + c_ad * AD[1] {1},
AO[2] = c_ab * AB[2] + c_ad * AD[2] {2}.</code></pre><p>One may note that AB[1] * {2} - AB[2] * {1} implies that</p><pre><code class="nohighlight hljs">AB[1] * AO[2] - AB[2] * AO[1] = c_ad * AD[2] * AB[1] - c_ad * AD[1] * AB[2]</code></pre><p>that can be further rewritten as</p><pre><code class="nohighlight hljs">c_ad = (AB[1] * AO[2] - AB[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).</code></pre><p>Similarly, AD[1] * {2} - AD[2] * {1} implies that</p><pre><code class="nohighlight hljs">c_ab = -(AD[1] * AO[2] - AD[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).</code></pre><p>This decomposition allows us to determine whether the cell O is inside the rectangle area, since this requires c<em>ab and c</em>ad to be between 0 and 1.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>By convention, the decomposition is done at the top right corner of each cell.</li></ul><p><strong>Inputs</strong></p><ul><li><code>ab_ind::Vector{Float64}</code>: Indices representing the edge AB of the rectangle.</li><li><code>ad_ind::Vector{Float64}</code>: Indices representing the edge AD of the rectangle.</li><li><code>a_ind::Vector{Float64}</code>: Indices of the vertex A from which the edges AB and AD start.</li><li><code>area_min_x::Int64</code>: Minimum index in the X direction of the specified area.</li><li><code>area_min_y::Int64</code>: Minimum index in the Y direction of the specified area.</li><li><code>area_length_x::Int64</code>: Number of grid elements in the X direction of the specified area.</li><li><code>area_length_y::Int64</code>: Number of grid elements in the Y direction of the specified area.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>c_ab::Matrix{Float64}</code>: Results of the vector decomposition in terms of the AB component.</li><li><code>c_ad::Matrix{Float64}</code>: Results of the vector decomposition in terms of the AD component.</li><li><code>in_rectangle::Matrix{Bool}</code>: Indicates whether the cell is inside the rectangle area.</li><li><code>n_cell::Int64</code>: Number of cells inside the rectangle area.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">ab_ind = [0, 4, 0]
ad_ind = [3, 0, 0]
a_ind = [10, 8, 25]

c_ab, c_ad, in_rectangle, n_cell = _decompose_vector_rectangle(
    ab_ind, ad_ind, a_ind, 15, 12, 8, 7
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/88a3d7cd0e931d58097508a3c26d34981e4c0772/src/bucket.jl#L270-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._decompose_vector_triangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._decompose_vector_triangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._decompose_vector_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_decompose_vector_triangle(
    ab_ind::Vector{T}, ac_ind::Vector{T}, a_ind::Vector{T},
    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function performs a vector decomposition on a portion of the horizontal plane where a triangle ABC is located. The position of the triangle is defined by its edges AB and AC , while the specified area extends over [<code>area_min_x</code>, <code>area_min_x + area_length_x</code>] on the X direction and [<code>area_min_y</code>, <code>area_min_y + area_length_y</code>] on the Y direction.</p><p>For each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AC. Let O be the name of a cell, it can then be decomposed as</p><pre><code class="nohighlight hljs">AO = c_ab * AB + c_ac * AC.</code></pre><p>This decomposition leads to a system of 2 equations with 2 unknowns (c<em>ab and c</em>ac)</p><pre><code class="nohighlight hljs">AO[1] = c_ab * AB[1] + c_ac * AC[1] {1},
AO[2] = c_ab * AB[2] + c_ac * AC[2] {2}.</code></pre><p>One may note that AB[1] * {2} - AB[2] * {1} implies that</p><pre><code class="nohighlight hljs">AB[1] * AO[2] - AB[2] * AO[1] = c_ac * AC[2] * AB[1] - c_ac * AC[1] * AB[2]</code></pre><p>that can be further rewritten as</p><pre><code class="nohighlight hljs">c_ac = (AB[1] * AO[2] - AB[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).</code></pre><p>Similarly, AC[1] * {2} - AC[2] * {1} implies that</p><pre><code class="nohighlight hljs">c_ab = -(AC[1] * AO[2] - AC[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).</code></pre><p>This decomposition allows us to determine whether the cell O is inside the triangle area, since this requires c<em>ab and c</em>ac to be between 0 and 1, and the sum of c<em>ab and c</em>ac to be lower than 1.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>By convention, the decomposition is done at the top right corner of each cell.</li></ul><p><strong>Inputs</strong></p><ul><li><code>ab_ind::Vector{Float64}</code>: Indices representing the edge AB of the triangle.</li><li><code>ac_ind::Vector{Float64}</code>: Indices representing the edge AC of the triangle.</li><li><code>a_ind::Vector{Float64}</code>: Indices of the vertex A from which the edges AB and AC start.</li><li><code>area_min_x::Int64</code>: Minimum index in the X direction of the specified area.</li><li><code>area_min_y::Int64</code>: Minimum index in the Y direction of the specified area.</li><li><code>area_length_x::Int64</code>: Number of grid elements in the X direction of the specified area.</li><li><code>area_length_y::Int64</code>: Number of grid elements in the Y direction of the specified area.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>c_ab::Matrix{Float64}</code>: Results of the vector decomposition in terms of the AB component.</li><li><code>c_ac::Matrix{Float64}</code>: Results of the vector decomposition in terms of the AC component.</li><li><code>in_triangle::Matrix{Bool}</code>: Indicates whether the cell is inside the triangle area.</li><li><code>n_cell::Int64</code>: Number of cells inside the triangle area.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">ab_ind = [0, 4, 0]
ac_ind = [3, 0, 0]
a_ind = [10, 8, 25]

c_ab, c_ac, in_triangle, n_cell = _decompose_vector_triangle(
    ab_ind, ac_ind, a_ind, 15, 12, 8, 7
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/88a3d7cd0e931d58097508a3c26d34981e4c0772/src/bucket.jl#L528-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._include_new_body_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T, T}, Tuple{SimOut{B, I, T}, I, I, T, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._include_new_body_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T, T}, Tuple{SimOut{B, I, T}, I, I, T, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._include_new_body_pos!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_include_new_body_pos!(
    out::SimOut{B,I,T}, ii::I, jj::I, min_h::T, max_h::T, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function updates the bucket position in <code>body</code> at the coordinates (<code>ii</code>, <code>jj</code>). The minimum and maximum heights of the bucket at that position are given by <code>min_h</code> and <code>max_h</code>, respectively. If the given position overlaps with an existing position, then the existing position is updated as the union of the two positions. Otherwise, a new position is added to <code>body</code>.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>ii::Int64</code>: Index of the considered position in the X direction.</li><li><code>jj::Int64</code>: Index of the considered position in the Y direction.</li><li><code>min_h::Float64</code>: Minimum height of the bucket. [m]</li><li><code>max_h::Float64</code>: Maximum height of the bucket. [m]</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_include_new_body_pos!(out, 10, 15, 0.5, 0.6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/88a3d7cd0e931d58097508a3c26d34981e4c0772/src/bucket.jl#L805-L837">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._update_body!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._update_body!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._update_body!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_update_body!(
    area_pos::Vector{Vector{I}}, out::SimOut{B,I,T}, grid::GridParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function updates the bucket position in <code>body</code> following the cells composing <code>area_pos</code>. For each XY position, the first cell found in <code>area_pos</code> corresponds to the minimum height of the bucket, while the last one provides the maximum height. As a result, this function must be called separately for each bucket wall.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li><code>area_pos</code> must be sorted and not be empty.</li></ul><p><strong>Inputs</strong></p><ul><li><code>area_pos::Vector{Vector{Int64}}</code>: A collection of cell indices specifying where a bucket                                    wall is located.</li><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)
a = [1.0, 0.0, 0.7]
b = [0.0, 1.0, 0.7]
c = [0.0, 1.0, 0.9]
tri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)

_update_body!(tri_pos, out, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/88a3d7cd0e931d58097508a3c26d34981e4c0772/src/bucket.jl#L732-L768">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« types.jl</a><a class="docs-footer-nextpage" href="../body_soil/">body_soil.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 6 June 2023 01:15">Tuesday 6 June 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
