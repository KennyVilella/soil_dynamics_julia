<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>bucket.jl · Soil dynamics simulator</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Soil dynamics simulator</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">types.jl</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li class="is-active"><a class="tocitem" href>bucket.jl</a><ul class="internal"><li><a class="tocitem" href="#General-description-of-the-simulated-excavator-bucket"><span>General description of the simulated excavator bucket</span></a></li><li><a class="tocitem" href="#Determination-of-the-bucket-position"><span>Determination of the bucket position</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../body_soil/">body_soil.jl</a></li><li><a class="tocitem" href="../intersecting_cells/">intersecting_cells.jl</a></li><li><a class="tocitem" href="../relax/">relax.jl</a></li><li><a class="tocitem" href="../utils/">utils.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>bucket.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>bucket.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/main/docs/src/bucket.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation-for-bucket.jl"><a class="docs-heading-anchor" href="#Documentation-for-bucket.jl">Documentation for bucket.jl</a><a id="Documentation-for-bucket.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-for-bucket.jl" title="Permalink"></a></h1><h2 id="General-description-of-the-simulated-excavator-bucket"><a class="docs-heading-anchor" href="#General-description-of-the-simulated-excavator-bucket">General description of the simulated excavator bucket</a><a id="General-description-of-the-simulated-excavator-bucket-1"></a><a class="docs-heading-anchor-permalink" href="#General-description-of-the-simulated-excavator-bucket" title="Permalink"></a></h2><p>The excavator&#39;s bucket has usually a complex shape that is not suitable for first-order modelling. In this simulator, the bucket is approximated as a triangular prism to simplify its representation. An illustration of the simulated bucket is provided below.</p><p><img src="./assets/bucket.png &quot;Approximated bucket&quot;" alt="Approximated bucket"/></p><p>The different parts of the bucket are labeled as follows:</p><ul><li><code>J</code> represents the bucket joint.</li><li><code>B</code> represents the bucket base.</li><li><code>T</code> represents the bucket teeth.</li><li>The surface defined by the vertices <span>$T_lT_rB_rB_l$</span> is referred to as the bucket base.</li><li>The surface defined by the vertices <span>$J_lJ_rB_rB_l$</span> is referred to as the bucket back.</li><li>The surface defined by the vertices <span>$J_rB_rT_r$</span> is referred to as the bucket right side.</li><li>The surface defined by the vertices <span>$J_lB_lT_l$</span> is referred to as the bucket left side.</li><li>The surface defined by the vertices <span>$J_lJ_rT_rT_l$</span> is referred to as the bucket front. Note that it does not correspond to a bucket wall.</li></ul><p>The reference pose of the bucket is specified when creating the <code>BucketParam</code> struct and is defined by the fields <code>j_pos_init</code>, <code>b_pos_init</code>, and <code>t_pos_init</code>, which correspond to the positions of the bucket joint, base, and teeth, respectively. The center of rotation for the bucket is typically the bucket joint, but it can be a different point depending on the specific bucket design. In that case, a different bucket origin can be provided when building <code>BucketParam</code>. The position of the bucket joint, base, and teeth are generally defined relative to the bucket origin.</p><p>The pose of the bucket is provided to the simulator as the Cartesian position of the bucket origin and its orientation relative to the reference pose, using the <code>Quaternion</code> notation.</p><h2 id="Determination-of-the-bucket-position"><a class="docs-heading-anchor" href="#Determination-of-the-bucket-position">Determination of the bucket position</a><a id="Determination-of-the-bucket-position-1"></a><a class="docs-heading-anchor-permalink" href="#Determination-of-the-bucket-position" title="Permalink"></a></h2><p>The purpose of the functions in this file is to determine the position of the excavator bucket within the 3D grid. Specifically, it aims to identify, for each XY position in the grid, the minimum and maximum height of the bucket if it is present at that location. The algorithm used for this task has been optimized for performance, resulting in a highly efficient implementation. However, due to the optimization, the algorithm may appear complex or unintuitive.</p><p>The basic idea under the implementation is to decompose the bucket into its 4 surfaces (base, back, left side, right side), and to identify for each XY position of the grid the minimum and maximum height of the given bucket wall. The results for the four surfaces are then aggregated, sorted and duplicates are removed. It is then straightforward to determine for each XY position the minimum and maximum height of the bucket using this information. Although a different implementation is present for the rectangular surfaces (base and back) and for the triangular surfaces (left and right side), the algorithm is almost identical.</p><p>The position of the bucket wall is determined using a three-steps process:</p><ul><li>(1) Each XY position within the bounding box of the bucket wall is decomposed into the reference vectors of the considered surface. This allows to easily determine whether a given XY position falls inside or outside the projection of the bucket wall into the horizontal plane.</li><li>(2) For each XY position (<code>ii</code>, <code>jj</code>) within the projection of the bucket wall into the horizontal plane, the height of the bucket wall at the cell corner (<code>ii + 0.5</code>, <code>jj + 0.5</code>) is calculated and added to the tally. By iterating over all the cells, the algorithm ensures that the height of the bucket is calculated at the 4 corners of each cell within the projection of the bucket wall into the horizontal plane. This is crucial because the minimum and maximum height of a plane intersecting laterally a cell is occuring necesserarily at one of the cell&#39;s corner.</li><li>(3) An issue of this algorithm is that it does not handle the case where the bucket wall is either not fully intersecting the cell or intersecting vertically the cell. Those cases are handled separately by identifying all the cells where the edges of the bucket wall are located. This is simply done by decomposing each edges into a certain number of equally spaced points, and then determining where each points is located.</li></ul><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._calc_bucket_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_bucket_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_bucket_pos!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_bucket_pos!(
    out::SimOut{B,I,T}, pos::Vector{T}, ori::Quaternion{T}, grid::GridParam{I,T},
    bucket::BucketParam{I,T}, sim::SimParam{I,T}, step_bucket_grid::T=0.5, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function determines all the cells where the bucket is located. The bucket position is calculated based on its reference pose stored in the <code>bucket</code> struct, as well as the provided position (<code>pos</code>) and orientation (<code>ori</code>). <code>pos</code> and <code>ori</code> are used to apply the appropriate translation and rotation to the bucket relative to its reference pose. The center of rotation is assumed to be the bucket origin. The orientation is provided using the quaternion definition.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>pos::Vector{Float64}</code>: Cartesian coordinates of the bucket origin. [m]</li><li><code>ori::Quaternion{Float64}</code>: Orientation of the bucket. [Quaternion]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li><li><code>sim::SimParam{Int64,Float64}</code>: Struct that stores information related to the                                 simulation.</li><li><code>step_bucket_grid::Float64</code>: Spatial increment used to decompose the edges of the bucket.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">pos = [0.5, 0.3, 0.4]
ori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)
grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)
sim = SimParam(0.85, 3, 4)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_calc_bucket_pos!(out, pos, ori, grid, bucket, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/b26ed07ff1c612ffb0c3bc9eab4b5f17387feb13/src/bucket.jl#L9-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._calc_line_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, T, GridParam{I, T}}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_line_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, T, GridParam{I, T}}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_line_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_line_pos(
    a::Vector{T}, b::Vector{T}, delta::T, grid::GridParam{I,T}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function determines all the cells that lie on a straight line between two Cartesian coordinates.</p><p>For the sake of accuracy, the line is divided into smaller segments using a spatial increment <code>delta</code>.</p><p>The coordinates of each sub-point (ab_i) along the line can then be calculated as</p><pre><code class="nohighlight hljs">ab_i = a + ab * i * delta / norm(ab)</code></pre><p>where i is the increment number and ab = b - a. The Cartesian coordinates can then be converted into indices</p><pre><code class="nohighlight hljs">ab_i_ind = ab_i / cell_size + grid_half_length + 1</code></pre><p>Finally, the floating-point values are rounded to obtain the cell indices in the X, Y, Z directions. As the center of each cell is considered to be on the center of the top surface, <code>round</code> should be used for getting the cell indices in the X and Y direction, while <code>ceil</code> should be used for the Z direction.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>When the line follows a cell border, the exact location of the line becomes ambiguous. It is assumed that the caller resolves this ambiguity.</li></ul><p><strong>Inputs</strong></p><ul><li><code>a::Vector{Float64}</code>: Cartesian coordinates of the first extremity of the line. [m]</li><li><code>b::Vector{Float64}</code>: Cartesian coordinates of the second extremity of the line. [m]</li><li><code>delta::Float64</code>: Spatial increment used to decompose the line. [m]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li></ul><p><strong>Outputs</strong></p><ul><li><code>line_pos::Vector{Vector{Int64}}</code>: Collection of cells indices where the line is located.                                    Result is not sorted and duplicates should be expected.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
a = [1.0, 0.5, 0.7]
b = [0.7, 0.8, -0.3]

line_pos = _calc_line_pos(a, b, 0.01, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/b26ed07ff1c612ffb0c3bc9eab4b5f17387feb13/src/bucket.jl#L687-L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._calc_rectangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_rectangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_rectangle_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_rectangle_pos(
    a::Vector{T}, b::Vector{T}, c::Vector{T}, d::Vector{T},
    delta::T, grid::GridParam{I,T}, tol::T=1e-8
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function determines the cells where a rectangle surface is located. The rectangle is defined by providing the Cartesian coordinates of its four vertices in the proper order.</p><p>To optimize performance, the function iterates over a portion of the horizontal grid where the rectangle is located. For each cell, the function calculates the height of the plane formed by the rectangle at the top right corner of the cell. If the cell is within the rectangle area, the calcualted height is added to the results for the four neighboring cells.</p><p>This method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.</p><p>However, this approach does not work when the rectangle is perpendicular to the XY plane. To handle this case, the function uses the <code>_calc_line_pos</code> function to include the cells that lie on the four edges of the rectangle.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.</li><li>Not all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.</li><li>When the rectangle follows a cell border, the exact location of the rectangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.</li></ul><p><strong>Inputs</strong></p><ul><li><code>a::Vector{Float64}</code>: Cartesian coordinates of one vertex of the rectangle. [m]</li><li><code>b::Vector{Float64}</code>: Cartesian coordinates of one vertex of the rectangle. [m]</li><li><code>c::Vector{Float64}</code>: Cartesian coordinates of one vertex of the rectangle. [m]</li><li><code>d::Vector{Float64}</code>: Cartesian coordinates of one vertex of the rectangle. [m]</li><li><code>delta::Float64</code>: Spatial increment used to decompose the edges of the rectangle. [m]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>: Collection of cells indices where the rectangle is located.                          Result is not sorted and duplicates may be present.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
a = [1.0, 0.0, 0.7]
b = [0.0, 1.0, 0.7]
c = [0.0, 1.0, 0.9]
d = [1.0, 0.0, 0.9]

rect_pos = _calc_rectangle_pos(a, b, c, d, 0.01, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/b26ed07ff1c612ffb0c3bc9eab4b5f17387feb13/src/bucket.jl#L165-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._calc_triangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_triangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_triangle_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_triangle_pos(
    a::Vector{T}, b::Vector{T}, c::Vector{T},
    delta::T, grid::GridParam{I,T}, tol::T=1e-8
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function determines the cells where a triangle surface is located. The triangle is defined by providing the Cartesian coordinates of its three vertices in the proper order.</p><p>To optimize performance, the function iterates over a portion of the horizontal grid where the triangle is located. For each cell, the function calculates the height of the plane formed by the triangle at the top right corner of the cell. If the cell is within the triangle area, the calcualted height is added to the results for the four neighboring cells.</p><p>This method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.</p><p>However, this approach does not work when the triangle is perpendicular to the XY plane. To handle this case, the function uses the <code>_calc_line_pos</code> function to include the cells that lie on the three edges of the triangle.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.</li><li>Not all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.</li><li>When the triangle follows a cell border, the exact location of the triangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.</li></ul><p><strong>Inputs</strong></p><ul><li><code>a::Vector{Float64}</code>: Cartesian coordinates of one vertex of the triangle. [m]</li><li><code>b::Vector{Float64}</code>: Cartesian coordinates of one vertex of the triangle. [m]</li><li><code>c::Vector{Float64}</code>: Cartesian coordinates of one vertex of the triangle. [m]</li><li><code>delta::Float64</code>: Spatial increment used to decompose the edges of the triangle. [m]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>: Collection of cells indices where the triangle is located.                          Result is not sorted and duplicates may be present.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
a = [1.0, 0.0, 0.7]
b = [0.0, 1.0, 0.7]
c = [0.0, 1.0, 0.9]

tri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/b26ed07ff1c612ffb0c3bc9eab4b5f17387feb13/src/bucket.jl#L428-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._decompose_vector_rectangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._decompose_vector_rectangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._decompose_vector_rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_decompose_vector_rectangle(
    ab_ind::Vector{T}, ad_ind::Vector{T}, a_ind::Vector{T},
    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function performs a vector decomposition on a portion of the horizontal plane where a rectangle ABCD is located. The position of the rectangle is defined by its edges AB and AD, while the specified area extends over [<code>area_min_x</code>, <code>area_min_x + area_length_x</code>] on the X direction and [<code>area_min_y</code>, <code>area_min_y + area_length_y</code>] on the Y direction.</p><p>For each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AD. Let O be the name of a cell, it can then be decomposed as</p><pre><code class="nohighlight hljs">AO = c_ab * AB + c_ad * AD.</code></pre><p>This decomposition leads to a system of 2 equations with 2 unknowns (c<em>ab and c</em>ad)</p><pre><code class="nohighlight hljs">AO[1] = c_ab * AB[1] + c_ad * AD[1] {1},
AO[2] = c_ab * AB[2] + c_ad * AD[2] {2}.</code></pre><p>One may note that AB[1] * {2} - AB[2] * {1} implies that</p><pre><code class="nohighlight hljs">AB[1] * AO[2] - AB[2] * AO[1] = c_ad * AD[2] * AB[1] - c_ad * AD[1] * AB[2]</code></pre><p>that can be further rewritten as</p><pre><code class="nohighlight hljs">c_ad = (AB[1] * AO[2] - AB[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).</code></pre><p>Similarly, AD[1] * {2} - AD[2] * {1} implies that</p><pre><code class="nohighlight hljs">c_ab = -(AD[1] * AO[2] - AD[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).</code></pre><p>This decomposition allows us to determine whether the cell O is inside the rectangle area, since this requires c<em>ab and c</em>ad to be between 0 and 1.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>By convention, the decomposition is done at the top right corner of each cell.</li></ul><p><strong>Inputs</strong></p><ul><li><code>ab_ind::Vector{Float64}</code>: Indices representing the edge AB of the rectangle.</li><li><code>ad_ind::Vector{Float64}</code>: Indices representing the edge AD of the rectangle.</li><li><code>a_ind::Vector{Float64}</code>: Indices of the vertex A from which the edges AB and AD start.</li><li><code>area_min_x::Int64</code>: Minimum index in the X direction of the specified area.</li><li><code>area_min_y::Int64</code>: Minimum index in the Y direction of the specified area.</li><li><code>area_length_x::Int64</code>: Number of grid elements in the X direction of the specified area.</li><li><code>area_length_y::Int64</code>: Number of grid elements in the Y direction of the specified area.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>c_ab::Matrix{Float64}</code>: Results of the vector decomposition in terms of the AB component.</li><li><code>c_ad::Matrix{Float64}</code>: Results of the vector decomposition in terms of the AD component.</li><li><code>in_rectangle::Matrix{Bool}</code>: Indicates whether the cell is inside the rectangle area.</li><li><code>n_cell::Int64</code>: Number of cells inside the rectangle area.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">ab_ind = [0, 4, 0]
ad_ind = [3, 0, 0]
a_ind = [10, 8, 25]

c_ab, c_ad, in_rectangle, n_cell = _decompose_vector_rectangle(
    ab_ind, ad_ind, a_ind, 15, 12, 8, 7
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/b26ed07ff1c612ffb0c3bc9eab4b5f17387feb13/src/bucket.jl#L310-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._decompose_vector_triangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._decompose_vector_triangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._decompose_vector_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_decompose_vector_triangle(
    ab_ind::Vector{T}, ac_ind::Vector{T}, a_ind::Vector{T},
    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function performs a vector decomposition on a portion of the horizontal plane where a triangle ABC is located. The position of the triangle is defined by its edges AB and AC , while the specified area extends over [<code>area_min_x</code>, <code>area_min_x + area_length_x</code>] on the X direction and [<code>area_min_y</code>, <code>area_min_y + area_length_y</code>] on the Y direction.</p><p>For each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AC. Let O be the name of a cell, it can then be decomposed as</p><pre><code class="nohighlight hljs">AO = c_ab * AB + c_ac * AC.</code></pre><p>This decomposition leads to a system of 2 equations with 2 unknowns (c<em>ab and c</em>ac)</p><pre><code class="nohighlight hljs">AO[1] = c_ab * AB[1] + c_ac * AC[1] {1},
AO[2] = c_ab * AB[2] + c_ac * AC[2] {2}.</code></pre><p>One may note that AB[1] * {2} - AB[2] * {1} implies that</p><pre><code class="nohighlight hljs">AB[1] * AO[2] - AB[2] * AO[1] = c_ac * AC[2] * AB[1] - c_ac * AC[1] * AB[2]</code></pre><p>that can be further rewritten as</p><pre><code class="nohighlight hljs">c_ac = (AB[1] * AO[2] - AB[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).</code></pre><p>Similarly, AC[1] * {2} - AC[2] * {1} implies that</p><pre><code class="nohighlight hljs">c_ab = -(AC[1] * AO[2] - AC[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).</code></pre><p>This decomposition allows us to determine whether the cell O is inside the triangle area, since this requires c<em>ab and c</em>ac to be between 0 and 1, and the sum of c<em>ab and c</em>ac to be lower than 1.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>By convention, the decomposition is done at the top right corner of each cell.</li></ul><p><strong>Inputs</strong></p><ul><li><code>ab_ind::Vector{Float64}</code>: Indices representing the edge AB of the triangle.</li><li><code>ac_ind::Vector{Float64}</code>: Indices representing the edge AC of the triangle.</li><li><code>a_ind::Vector{Float64}</code>: Indices of the vertex A from which the edges AB and AC start.</li><li><code>area_min_x::Int64</code>: Minimum index in the X direction of the specified area.</li><li><code>area_min_y::Int64</code>: Minimum index in the Y direction of the specified area.</li><li><code>area_length_x::Int64</code>: Number of grid elements in the X direction of the specified area.</li><li><code>area_length_y::Int64</code>: Number of grid elements in the Y direction of the specified area.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>c_ab::Matrix{Float64}</code>: Results of the vector decomposition in terms of the AB component.</li><li><code>c_ac::Matrix{Float64}</code>: Results of the vector decomposition in terms of the AC component.</li><li><code>in_triangle::Matrix{Bool}</code>: Indicates whether the cell is inside the triangle area.</li><li><code>n_cell::Int64</code>: Number of cells inside the triangle area.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">ab_ind = [0, 4, 0]
ac_ind = [3, 0, 0]
a_ind = [10, 8, 25]

c_ab, c_ac, in_triangle, n_cell = _decompose_vector_triangle(
    ab_ind, ac_ind, a_ind, 15, 12, 8, 7
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/b26ed07ff1c612ffb0c3bc9eab4b5f17387feb13/src/bucket.jl#L568-L634">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._include_new_body_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T, T}, Tuple{SimOut{B, I, T}, I, I, T, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._include_new_body_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T, T}, Tuple{SimOut{B, I, T}, I, I, T, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._include_new_body_pos!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_include_new_body_pos!(
    out::SimOut{B,I,T}, ii::I, jj::I, min_h::T, max_h::T, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function updates the bucket position in <code>body</code> at the coordinates (<code>ii</code>, <code>jj</code>). The minimum and maximum heights of the bucket at that position are given by <code>min_h</code> and <code>max_h</code>, respectively. If the given position overlaps with an existing position, then the existing position is updated as the union of the two positions. Otherwise, a new position is added to <code>body</code>.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>ii::Int64</code>: Index of the considered position in the X direction.</li><li><code>jj::Int64</code>: Index of the considered position in the Y direction.</li><li><code>min_h::Float64</code>: Minimum height of the bucket. [m]</li><li><code>max_h::Float64</code>: Maximum height of the bucket. [m]</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_include_new_body_pos!(out, 10, 15, 0.5, 0.6)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/b26ed07ff1c612ffb0c3bc9eab4b5f17387feb13/src/bucket.jl#L845-L877">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._update_body!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._update_body!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._update_body!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_update_body!(
    area_pos::Vector{Vector{I}}, out::SimOut{B,I,T}, grid::GridParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function updates the bucket position in <code>body</code> following the cells composing <code>area_pos</code>. For each XY position, the first cell found in <code>area_pos</code> corresponds to the minimum height of the bucket, while the last one provides the maximum height. As a result, this function must be called separately for each bucket wall.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li><code>area_pos</code> must be sorted and not be empty.</li></ul><p><strong>Inputs</strong></p><ul><li><code>area_pos::Vector{Vector{Int64}}</code>: A collection of cell indices specifying where a bucket                                    wall is located.</li><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)
a = [1.0, 0.0, 0.7]
b = [0.0, 1.0, 0.7]
c = [0.0, 1.0, 0.9]
tri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)

_update_body!(tri_pos, out, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/b26ed07ff1c612ffb0c3bc9eab4b5f17387feb13/src/bucket.jl#L772-L808">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../grid/">« Grid</a><a class="docs-footer-nextpage" href="../body_soil/">body_soil.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 19 July 2023 01:27">Wednesday 19 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
