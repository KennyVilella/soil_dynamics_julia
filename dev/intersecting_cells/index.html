<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>intersecting_cells.jl · Soil dynamics simulator</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Soil dynamics simulator</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">types.jl</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../bucket/">bucket.jl</a></li><li><a class="tocitem" href="../body_soil/">body_soil.jl</a></li><li class="is-active"><a class="tocitem" href>intersecting_cells.jl</a><ul class="internal"><li><a class="tocitem" href="#Introductory-remarks"><span>Introductory remarks</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../relax/">relax.jl</a></li><li><a class="tocitem" href="../utils/">utils.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>intersecting_cells.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>intersecting_cells.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/main/docs/src/intersecting_cells.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation-for-intersecting_cells.jl"><a class="docs-heading-anchor" href="#Documentation-for-intersecting_cells.jl">Documentation for intersecting_cells.jl</a><a id="Documentation-for-intersecting_cells.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-for-intersecting_cells.jl" title="Permalink"></a></h1><h2 id="Introductory-remarks"><a class="docs-heading-anchor" href="#Introductory-remarks">Introductory remarks</a><a id="Introductory-remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Introductory-remarks" title="Permalink"></a></h2><p>After updating the position of the bucket and the soil resting on the bucket, it is possible that some soil cells are located in the same position as a bucket wall, while it is obviously physically impossible to have both soil and the bucket at the same position. These soil cells are referred to as intersecting cells in the simulator.</p><p>The purpose of the functions in this file is to move these soil cells following a set of rules to ensure a physically valid simulation. The process involves two main steps: moving intersecting cells resting on the bucket and moving intersecting cells from the terrain. The order of these steps is crucial, as the movement of intersecting cells resting on the bucket can create new intersecting cells in the terrain.</p><h3 id="Movement-of-soil-cells-on-the-bucket-intersecting-with-the-bucket"><a class="docs-heading-anchor" href="#Movement-of-soil-cells-on-the-bucket-intersecting-with-the-bucket">Movement of soil cells on the bucket intersecting with the bucket</a><a id="Movement-of-soil-cells-on-the-bucket-intersecting-with-the-bucket-1"></a><a class="docs-heading-anchor-permalink" href="#Movement-of-soil-cells-on-the-bucket-intersecting-with-the-bucket" title="Permalink"></a></h3><h4 id="General-description"><a class="docs-heading-anchor" href="#General-description">General description</a><a id="General-description-1"></a><a class="docs-heading-anchor-permalink" href="#General-description" title="Permalink"></a></h4><p>This step focuses on relocating intersecting soil cells that are resting on the bucket. The process involves selecting randomly one of the eight directions surrounding the intersecting cells and investigating whether the soil can be moved in that direction. The algorithm explores positions incrementally farther from the intersecting cells until all the soil has been moved or a bucket wall blocks the movement. If a bucket wall blocks the movement, another direction is selected for investigation. In rare cases where not all soil can be moved after exploring all eight directions, a warning is issued, and the excess soil simply disappears. However, this edge case should not occur in normal scenarios.</p><p>Note: </p><ul><li>The investigated directions are randomized in order to avoid asymmetrical results.</li><li>There are necessarily two bucket layers where the intersecting soil cells are located.</li></ul><h4 id="Description-of-the-different-cases"><a class="docs-heading-anchor" href="#Description-of-the-different-cases">Description of the different cases</a><a id="Description-of-the-different-cases-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-the-different-cases" title="Permalink"></a></h4><h5 id="No-bucket-is-present"><a class="docs-heading-anchor" href="#No-bucket-is-present">No bucket is present</a><a id="No-bucket-is-present-1"></a><a class="docs-heading-anchor-permalink" href="#No-bucket-is-present" title="Permalink"></a></h5><p>In this case, the intersecting soil cells are simply moved to the terrain.</p><h5 id="One-bucket-layer"><a class="docs-heading-anchor" href="#One-bucket-layer">One bucket layer</a><a id="One-bucket-layer-1"></a><a class="docs-heading-anchor-permalink" href="#One-bucket-layer" title="Permalink"></a></h5><p>Three different cases are possible, as illustrated in the vertical slice diagram below:</p><p><img src="assets/intersecting_cells_1.png &quot;Intersecting bucket soil cells&quot;" alt="Intersecting bucket soil cells"/></p><p>(a) In this case, there is an open space below the bucket layer, and the remaining intersecting soil cells are moved to the terrain. This movement is independent of the available space below the bucket. If there is insufficient space, the soil is still moved, and the newly created intersecting soil cells will be addressed in the subsequent step.</p><p>(b) In this case, the remaining intersecting soil cells are moved to the top of the bucket layer. This movement is independent of whether soil is present on this bucket layer.</p><p>(c) In this case, the bucket layer in the new position extends over the two bucket layers from the previous position, creating a wall that prevents soil movement. The exploration in this direction is therefore halted.</p><p>Note that in this case the investigation of the considered direction will necessarily stop, either because of the presence of a bucket wall or because all the soil could be moved. That also means that the previous position has necessarily two bucket layers.</p><h5 id="Two-bucket-layers"><a class="docs-heading-anchor" href="#Two-bucket-layers">Two bucket layers</a><a id="Two-bucket-layers-1"></a><a class="docs-heading-anchor-permalink" href="#Two-bucket-layers" title="Permalink"></a></h5><p>Four different cases are possible, as illustrated in the vertical slice diagram below:</p><p><img src="assets/intersecting_cells_2.png &quot;Intersecting bucket soil cells&quot;" alt="Intersecting bucket soil cells"/></p><p>(a) In this case, the soil fully fills the space between the two bucket layers in the new position. No soil is moved to this position, but the exploration in this direction can continue.</p><p>(b) In this case, the combination of the bucket soil and the bottom bucket layer in the new position extends over the two bucket layers from the previous position. The intersecting cells are still moved to the available space, and the exploration in this direction continues.</p><p>(c) In this case, the combination of the bucket soil and the bottom bucket layer in the new position extends over the two bucket layers from the previous position. The intersecting cells are still moved to the available space, and the exploration in this direction continues.</p><p>(d) In this case, enough space is available between the two bucket layers to accommodate all the intersecting soil cells. The remaining intersecting cells are moved to this position.</p><h3 id="Movement-of-soil-cells-on-the-terrain-intersecting-with-the-bucket"><a class="docs-heading-anchor" href="#Movement-of-soil-cells-on-the-terrain-intersecting-with-the-bucket">Movement of soil cells on the terrain intersecting with the bucket</a><a id="Movement-of-soil-cells-on-the-terrain-intersecting-with-the-bucket-1"></a><a class="docs-heading-anchor-permalink" href="#Movement-of-soil-cells-on-the-terrain-intersecting-with-the-bucket" title="Permalink"></a></h3><h4 id="General-description-2"><a class="docs-heading-anchor" href="#General-description-2">General description</a><a class="docs-heading-anchor-permalink" href="#General-description-2" title="Permalink"></a></h4><p>This step focuses on relocating intersecting soil cells that are present in the terrain and intersect with the bucket. The algorithm investigates the eight cells surrounding the intersecting cells in a randomized order to determine if soil can be moved to those positions. If there is insufficient space for all the soil, the algorithm incrementally explores the eight directions farther from the intersecting soil column until all the soil has been relocated.</p><p>Note:</p><ul><li>The investigated directions are randomized in order to avoid asymmetrical results.</li><li>Soil is necessarily moved to the terrain. The digging is therefore a two-step process. Intersecting cells are first moved to the terrain just outside the bucket, then avalanche on the bucket during the relaxation step.</li></ul><h4 id="Description-of-the-different-cases-2"><a class="docs-heading-anchor" href="#Description-of-the-different-cases-2">Description of the different cases</a><a class="docs-heading-anchor-permalink" href="#Description-of-the-different-cases-2" title="Permalink"></a></h4><p>Three different cases are possible, as illustrated in the vertical slice diagram below:</p><p><img src="assets/intersecting_cells_3.png &quot;Intersecting terrain soil cells&quot;" alt="Intersecting terrain soil cells"/></p><p>(a) In this case, no bucket is present in the new position, and all the soil is moved to that position. This is done regardless of whether the bucket is buried deep underground.</p><p>(b) In this case, no space is available below the bucket, so no movement is made.</p><p>(c) In this case, some space is available below the bucket, and soil is moved to that position to fill the gap.</p><h3 id="Concluding-remarks"><a class="docs-heading-anchor" href="#Concluding-remarks">Concluding remarks</a><a id="Concluding-remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Concluding-remarks" title="Permalink"></a></h3><p>When the simulator would have the ability to handle multiple buckets, it may be necessary to handle the movement of soil resting on a bucket that intersects with a different bucket separately. Additionally, the case where a different bucket blocks the movement of soil to the terrain would need to be addressed.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._locate_intersecting_cells-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._locate_intersecting_cells-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._locate_intersecting_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_locate_intersecting_cells(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function identifies all the soil cells in the <code>terrain</code> that intersect with the bucket.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>: Collection of cells indices from the terrain intersecting with                          the bucket.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_locate_intersecting_cells(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/intersecting_cells.jl#L552-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._move_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._move_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._move_body_soil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_move_body_soil!(
    out::SimOut{B,I,T}, ind_p::I, ii_p::I, jj_p::I, max_h::T, ii_n::I, jj_n::I,
    h_soil::T, wall_presence::B, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function tries to move the soil cells resting on the bucket layer <code>ind_p</code> at the location (<code>ii_p</code>, <code>jj_p</code>) to a new location at (<code>ii_n</code>, <code>jj_n</code>).</p><p>This function can be separated into three main scenarios:</p><ul><li>If all the soil can be moved to the new location (either on the terrain or on the bucket), the soil is moved and the value of <code>h_soil</code> is set to zero.</li><li>If a bucket wall is blocking the movement, the <code>wall_presence</code> parameter is set to <code>true</code>.</li><li>If there is insufficient space to move all the soil but no bucket wall is blocking the movement, the function updates the values for the new location and adjusts <code>h_soil</code> accordingly.</li></ul><p>This function is designed to be used iteratively by <code>_move_intersecting_body_soil!</code> until all intersecting soil cells are moved.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>By convention, the soil can be moved from the bucket to the terrain even if the bucket is underground.</li><li>In cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the <code>_move_intersecting_body!</code> function.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>ind_p::Int64</code>: Index of the previous considered bucket layer.</li><li><code>ii_p::Int64</code>: Index of the previous considered position in the X direction.</li><li><code>jj_p::Int64</code>: Index of the previous considered position in the Y direction.</li><li><code>max_h::Float64</code>: Maximum height authorized for the movement. [m]</li><li><code>ii_n::Int64</code>: Index of the new considered position in the X direction.</li><li><code>jj_n::Int64</code>: Index of the new considered position in the Y direction.</li><li><code>h_soil::Float64</code>: Height of the soil column left to be moved. [m]</li><li><code>wall_presence::Bool</code>: Indicates whether a bucket wall is blocking the movement.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>ind_p::Int64</code>: Index of the new considered bucket layer.</li><li><code>ii_p::Int64</code>: Index of the new considered position in the X direction.</li><li><code>jj_p::Int64</code>: Index of the new considered position in the Y direction.</li><li><code>h_soil::Float64</code>: Height of the soil column left to be moved. [m]</li><li><code>wall_presence::Bool</code>: Indicates whether a bucket wall is blocking the movement.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

 ind_p, ii_p, jj_p, h_soil, wall_presence = _move_body_soil!(
     out, 1, 10, 15, 0.2, 10, 16, 0.2, true
 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/intersecting_cells.jl#L303-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._move_intersecting_body!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._move_intersecting_body!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._move_intersecting_body!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_move_intersecting_body!(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil cells in the <code>terrain</code> that intersect with a bucket. It checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces. If there is insufficient space for all the soil, it incrementally checks the eight directions farther from the intersecting soil column until all the soil has been moved. The process can be illustrated as follows</p><pre><code class="nohighlight hljs">             ↖   ↑   ↗
               ↖ ↑ ↗
             ← ← O → →
               ↙ ↓ ↘
             ↙   ↓   ↘</code></pre><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The order in which the directions are checked is randomized in order to avoid asymmetrical results.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_move_intersecting_body!(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/intersecting_cells.jl#L173-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._move_intersecting_body_soil!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._move_intersecting_body_soil!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._move_intersecting_body_soil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_move_intersecting_body_soil!(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil cells resting on the bucket that intersect with another bucket layer. It checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces.</p><p>The algorithm follows an incremental approach, checking directions farther from the  intersecting soil column until it reaches a bucket wall blocking the movement or until all the soil has been moved. If the movement is blocked by a bucket wall, the algorithm explores another direction.</p><p>In cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the <code>_move_intersecting_body!</code> function.</p><p>In rare situations where there is insufficient space to accommodate all the intersecting soil, the algorithm currently handles it by allowing the excess soil to simply disappear. This compromise seems to be reasonable as long as the amount of soil disappearing remains negligible.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The order in which the directions are checked is randomized in order to avoid asymmetrical results.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_move_intersecting_body_soil!(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/intersecting_cells.jl#L49-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._move_intersecting_cells!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._move_intersecting_cells!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._move_intersecting_cells!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_move_intersecting_cells!(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves all soil cells in <code>terrain</code> and in <code>body_soil</code> that intersect with the bucket or with another soil cell.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li><code>_move_intersecting_body_soil!</code> must be called before <code>_move_intersecting_body!</code>, otherwise some intersecting soil cells may remain.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_move_intersecting_cells!(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/intersecting_cells.jl#L9-L36">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../body_soil/">« body_soil.jl</a><a class="docs-footer-nextpage" href="../relax/">relax.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 18 July 2023 07:12">Tuesday 18 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
