<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>intersecting_cells.jl · Soil dynamics simulator</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Soil dynamics simulator</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">types.jl</a></li><li><a class="tocitem" href="../bucket/">bucket.jl</a></li><li><a class="tocitem" href="../body_soil/">body_soil.jl</a></li><li class="is-active"><a class="tocitem" href>intersecting_cells.jl</a></li><li><a class="tocitem" href="../relax/">relax.jl</a></li><li><a class="tocitem" href="../utils/">utils.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>intersecting_cells.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>intersecting_cells.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/main/docs/src/intersecting_cells.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation-for-intersecting_cells.jl"><a class="docs-heading-anchor" href="#Documentation-for-intersecting_cells.jl">Documentation for intersecting_cells.jl</a><a id="Documentation-for-intersecting_cells.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-for-intersecting_cells.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._locate_intersecting_cells-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._locate_intersecting_cells-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._locate_intersecting_cells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_locate_intersecting_cells(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function identifies all the soil cells in the <code>terrain</code> that intersect with the bucket.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>: Collection of cells indices from the terrain intersecting with                          the bucket.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_locate_intersecting_cells(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/7039202e182ac6f396ade1f34e691a3a7e23ad79/src/intersecting_cells.jl#L585-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._move_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._move_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._move_body_soil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_move_body_soil!(
    out::SimOut{B,I,T}, ind_p::I, ii_p::I, jj_p::I, max_h::T, ii_n::I, jj_n::I,
    h_soil::T, wall_presence::B, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function tries to move the soil cells resting on the bucket layer <code>ind_p</code> at the location (<code>ii_p</code>, <code>jj_p</code>) to a new location at (<code>ii_n</code>, <code>jj_n</code>).</p><p>This function can be separated into three main scenarios:</p><ul><li>If all the soil can be moved to the new location (either on the terrain or on the bucket), the soil is moved and the value of <code>h_soil</code> is set to zero.</li><li>If a bucket wall is blocking the movement, the <code>wall_presence</code> parameter is set to <code>true</code>.</li><li>If there is insufficient space to move all the soil but no bucket wall is blocking the movement, the function updates the values for the new location and adjusts <code>h_soil</code> accordingly.</li></ul><p>This function is designed to be used iteratively by <code>_move_intersecting_body_soil!</code> until all intersecting soil cells are moved.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>By convention, the soil can be moved from the bucket to the terrain even if the bucket is underground.</li><li>In cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the <code>_move_intersecting_body!</code> function.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>ind_p::Int64</code>: Index of the previous considered bucket layer.</li><li><code>ii_p::Int64</code>: Index of the previous considered position in the X direction.</li><li><code>jj_p::Int64</code>: Index of the previous considered position in the Y direction.</li><li><code>max_h::Float64</code>: Maximum height authorized for the movement. [m]</li><li><code>ii_n::Int64</code>: Index of the new considered position in the X direction.</li><li><code>jj_n::Int64</code>: Index of the new considered position in the Y direction.</li><li><code>h_soil::Float64</code>: Height of the soil column left to be moved. [m]</li><li><code>wall_presence::Bool</code>: Indicates whether a bucket wall is blocking the movement.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>ind_p::Int64</code>: Index of the new considered bucket layer.</li><li><code>ii_p::Int64</code>: Index of the new considered position in the X direction.</li><li><code>jj_p::Int64</code>: Index of the new considered position in the Y direction.</li><li><code>h_soil::Float64</code>: Height of the soil column left to be moved. [m]</li><li><code>wall_presence::Bool</code>: Indicates whether a bucket wall is blocking the movement.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

 ind_p, ii_p, jj_p, h_soil, wall_presence = _move_body_soil!(
     out, 1, 10, 15, 0.2, 10, 16, 0.2, true
 )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/7039202e182ac6f396ade1f34e691a3a7e23ad79/src/intersecting_cells.jl#L305-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._move_intersecting_body!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._move_intersecting_body!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._move_intersecting_body!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_move_intersecting_body!(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil cells in the <code>terrain</code> that intersect with a bucket. It checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces. If there is insufficient space for all the soil, it incrementally checks the eight directions farther from the intersecting soil column until all the soil has been moved. The process can be illustrated as follows</p><pre><code class="nohighlight hljs">             ↖   ↑   ↗
               ↖ ↑ ↗
             ← ← O → →
               ↙ ↓ ↘
             ↙   ↓   ↘</code></pre><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The order in which the directions are checked is randomized in order to avoid asymmetrical results.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_move_intersecting_body!(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/7039202e182ac6f396ade1f34e691a3a7e23ad79/src/intersecting_cells.jl#L175-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._move_intersecting_body_soil!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._move_intersecting_body_soil!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._move_intersecting_body_soil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_move_intersecting_body_soil!(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil cells resting on the bucket that intersect with another bucket layer. It checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces.</p><p>The algorithm follows an incremental approach, checking directions farther from the  intersecting soil column until it reaches a bucket wall blocking the movement or until all the soil has been moved. If the movement is blocked by a bucket wall, the algorithm explores another direction.</p><p>In cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the <code>_move_intersecting_body!</code> function.</p><p>In rare situations where there is insufficient space to accommodate all the intersecting soil, the algorithm currently handles it by allowing the excess soil to simply disappear. This compromise seems to be reasonable as long as the amount of soil disappearing remains negligible.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The order in which the directions are checked is randomized in order to avoid asymmetrical results.</li><li>By convention, the soil can be moved from the bucket to the terrain even if the bucket is underground.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_move_intersecting_body_soil!(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/7039202e182ac6f396ade1f34e691a3a7e23ad79/src/intersecting_cells.jl#L49-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._move_intersecting_cells!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._move_intersecting_cells!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._move_intersecting_cells!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_move_intersecting_cells!(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves all soil cells in <code>terrain</code> and in <code>body_soil</code> that intersect with the bucket or with another soil cell.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li><code>_move_intersecting_body_soil!</code> must be called before <code>_move_intersecting_body!</code>, otherwise some intersecting soil cells may remain.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_move_intersecting_cells!(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/7039202e182ac6f396ade1f34e691a3a7e23ad79/src/intersecting_cells.jl#L9-L36">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../body_soil/">« body_soil.jl</a><a class="docs-footer-nextpage" href="../relax/">relax.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 9 July 2023 01:38">Sunday 9 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
