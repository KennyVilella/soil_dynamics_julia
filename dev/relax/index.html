<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>relax.jl · Soil dynamics simulator</title><meta name="title" content="relax.jl · Soil dynamics simulator"/><meta property="og:title" content="relax.jl · Soil dynamics simulator"/><meta property="twitter:title" content="relax.jl · Soil dynamics simulator"/><meta name="description" content="Documentation for Soil dynamics simulator."/><meta property="og:description" content="Documentation for Soil dynamics simulator."/><meta property="twitter:description" content="Documentation for Soil dynamics simulator."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Soil dynamics simulator</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">types.jl</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../bucket/">bucket.jl</a></li><li><a class="tocitem" href="../body_soil/">body_soil.jl</a></li><li><a class="tocitem" href="../intersecting_cells/">intersecting_cells.jl</a></li><li class="is-active"><a class="tocitem" href>relax.jl</a><ul class="internal"><li><a class="tocitem" href="#Introductory-remarks"><span>Introductory remarks</span></a></li><li><a class="tocitem" href="#General-description"><span>General description</span></a></li><li><a class="tocitem" href="#Terrain-relaxation"><span>Terrain relaxation</span></a></li><li><a class="tocitem" href="#Bucket-soil-relaxation"><span>Bucket soil relaxation</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="../utils/">utils.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>relax.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>relax.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/KennyVilella/soil_dynamics_julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/main/docs/src/relax.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation-for-relax.jl"><a class="docs-heading-anchor" href="#Documentation-for-relax.jl">Documentation for relax.jl</a><a id="Documentation-for-relax.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-for-relax.jl" title="Permalink"></a></h1><h2 id="Introductory-remarks"><a class="docs-heading-anchor" href="#Introductory-remarks">Introductory remarks</a><a id="Introductory-remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Introductory-remarks" title="Permalink"></a></h2><p>The core function of the simulator is to model soil dynamics. Various models of different complexities have been developed over the years for this purpose. As this simulator focuses on performance, a simplified model is therefore employed. The model assumes that when the local slope of the soil exceeds its repose angle, the soil becomes unstable and needs to avalanche to neighboring cells to achieve a stable state where the local slope matches the repose angle. This action is referred to as &quot;relaxation&quot; in this simulator.</p><p>This soil relaxation process consists of two main steps: terrain relaxation and bucket soil relaxation. In the terrain relaxation, the unstable soil cells on the terrain are relaxed, potentially causing avalanches onto the bucket. Similarly, in the bucket soil relaxation, the unstable soil cells on the bucket are relaxed, potentially causing avalanches onto the terrain. It is important to note that the relaxation of soil cells can sometimes trigger instability in neighboring cells. As a result, the relaxation process needs to be repeated multiple times to achieve an equilibrium state. In practice, several thousand iterations may be required to reach full equilibrium, although the overall shape of the terrain can often be obtained after just a few iterations. To balance computational efficiency and accuracy, the algorithm does not wait for a complete equilibrium state and instead stops after a set number of iterations, which can be specified by the <code>max_iterations</code> field of the <code>SimParam</code> struct. The appropriate value for <code>max_iterations</code> typically ranges from 3 to 20 and should be chosen based on the specific simulation requirements. It is worth noting that increasing the value of <code>max_iterations</code> impacts significantly the performance of the simulator.</p><h2 id="General-description"><a class="docs-heading-anchor" href="#General-description">General description</a><a id="General-description-1"></a><a class="docs-heading-anchor-permalink" href="#General-description" title="Permalink"></a></h2><p>While the detailed implementation of the relaxation process differs for terrain relaxation and bucket soil relaxation, the core algorithm remains the same and will be described in this section.</p><p>The relaxation process consists of three steps.</p><p>The first step is to identify potentially unstable soil cells. This initial selection is not intended to be precise but rather to exclude cells that are obviously stable. To avoid asymmetrical results, the list of potential unstable cells is randomized. The soil cells in this list are then processed iteratively.</p><p>The second step is to check the stability of each considered soil cell in relation to its neighboring cells. By convention, relaxation is only performed in the X and Y directions, involving four adjacent cells and excluding diagonal cells. This choice is based on initial testing, which revealed that relaxing soil in 4 or 8 directions produced visually identical results. Relaxing in 8 directions allows for convergence to full equilibrium in less iterations than when relaxing in 4 directions, while requiring more computational time to perform each iteration. As a result, relaxing only in the X and Y directions produces a faster and simpler code. To avoid asymmetrical results, the order in which neighboring soil cells are checked is randomized. The result of this check is a status code consisting of two digits, providing a detailed indication of the condition of the soil cell.</p><p>The third step is the actual relaxation, which occurs only if the soil cell is determined to be unstable based on the status code obtained in the previous step. The relaxation process follows the specific instructions defined by the status code. The relaxation techniques for terrain relaxation and bucket soil relaxation will be explained separately in the following sections.</p><p>It is worth noting that the second and third steps could potentially be merged. However, separating these two steps improves code testability and maintainability.</p><h2 id="Terrain-relaxation"><a class="docs-heading-anchor" href="#Terrain-relaxation">Terrain relaxation</a><a id="Terrain-relaxation-1"></a><a class="docs-heading-anchor-permalink" href="#Terrain-relaxation" title="Permalink"></a></h2><p>This corresponds to the relaxation process performed by the function <code>_relax_terrain!</code>. Note that the meaning of the two-digit codes given by the function <code>_check_unstable_terrain_cell</code> and used by the function <code>_relax_unstable_terrain_cell!</code> is explained in the docstring of the function <code>_check_unstable_terrain_cell</code>. In this section, the main focus is to explain the physical reasoning behind the implementation of the <code>_relax_unstable_terrain_cell!</code> function.</p><h3 id="Description-of-the-different-cases"><a class="docs-heading-anchor" href="#Description-of-the-different-cases">Description of the different cases</a><a id="Description-of-the-different-cases-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-the-different-cases" title="Permalink"></a></h3><p>Mainly four different cases are possible, as illustrated in the vertical slice diagram below. Note that, for illustration purposes, it is assumed that the repose angle allows only for one cell difference between neighboring cells.</p><p><img src="../assets/relax_terrain.png" alt="Terrain relaxation"/></p><p>(a) In this case, there is no bucket, the soil can freely avalanche to the neighboring cell, reaching a stable configuration.</p><p>(b) In this case, there is some space available below the bucket, the soil can avalanche into that position to fill the gap. Note that the soil column would still be unstable after this movement, requiring a second iteration to reach a stable configuration.</p><p>(c) In this case, there is enough space available below the bucket to reach a stable configuration.</p><p>(d) In this case, the soil can avalanche on the top of the bucket and reach a stable configuration. Note that this is the only case in the simulator where soil from the terrain can be transferred to the bucket. Consequently, all bucket soil is generated from this case. If the soil can avalanche onto two bucket layers, then the lowest bucket layer has the priority.</p><p>It is worth mentioning that the order of these cases is important, as case (d) will only occur if cases (b) and (c) are not possible.</p><h3 id="Impact-area"><a class="docs-heading-anchor" href="#Impact-area">Impact area</a><a id="Impact-area-1"></a><a class="docs-heading-anchor-permalink" href="#Impact-area" title="Permalink"></a></h3><p>For performance optimization, the simulator only checks for soil instability within the lateral area specified by the <code>impact_area</code> field of the <code>SimOut</code> struct. The <code>impact_area</code> is a union of two areas: the <code>bucket_area</code>, which corresponds to the lateral area where the bucket is located, and the <code>relax_area</code>, which corresponds to the lateral area where unstable soil has been identified in the previous step. By limiting the analysis to this specific region, the simulator achieves significant performance gains and becomes almost independent of the grid size.</p><h2 id="Bucket-soil-relaxation"><a class="docs-heading-anchor" href="#Bucket-soil-relaxation">Bucket soil relaxation</a><a id="Bucket-soil-relaxation-1"></a><a class="docs-heading-anchor-permalink" href="#Bucket-soil-relaxation" title="Permalink"></a></h2><p>This corresponds to the relaxation process performed by the function <code>_relax_body_soil!</code>. Note that the meaning of the two-digit codes given by the function <code>_check_unstable_body_cell</code> and used by the function <code>_relax_unstable_body_cell!</code> is explained in the docstring of the function <code>_check_unstable_body_cell</code>. In this section, the main focus is to explain the physical reasoning behind the implementation of the <code>_relax_unstable_body_cell!</code> function.</p><h3 id="Description-of-the-different-cases-2"><a class="docs-heading-anchor" href="#Description-of-the-different-cases-2">Description of the different cases</a><a class="docs-heading-anchor-permalink" href="#Description-of-the-different-cases-2" title="Permalink"></a></h3><p>Mainly four different cases are possible, as illustrated in the vertical slice diagram below. Note that, for illustration purposes, it is assumed that the repose angle allows only for one cell difference between neighboring cells.</p><p><img src="../assets/relax_body_soil.png" alt="Bucket soil relaxation"/></p><p>(a) In this case, there is no bucket, the soil can freely avalanche to the neighboring cell, reaching a stable configuration.</p><p>(b) In this case, there is one bucket layer, the soil can freely avalanche onto the bucket, forming a stable configuration.</p><p>(c) In this case, there is one bucket layer, the soil can avalanche from one bucket layer to another, forming a stable configuration.</p><p>(d) In this case, there are two bucket layers, the soil can avalanche to one of the two adjacent bucket layer. Note that the top bucket layer has priority in the case where the soil can avalanche to both bucket layer, while, in the case where the soil should avalanche on the bottom layer, there may not be enough space for all the soil to avalanche, leading to a final state that may not be in equilibrium.</p><p>It is important to note that the presence of the bucket at the base of the soil column adds complexity to the relaxation process. There are cases where all the soil on a bucket layer can avalanche, while in other cases, only a portion of the soil may avalanche. It is crucial to handle these cases appropriately to ensure mass conservation during the relaxation process.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._check_unstable_body_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._check_unstable_body_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._check_unstable_body_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_check_unstable_body_cell(
    out::SimOut{B,I,T}, ii::I, jj::I, ind::I, ii_c::I, jj_c::I, h_min::T, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function checks the stability of a soil column in the soil layer <code>ind</code> of <code>body_soil</code> at (<code>ii</code>, <code>jj</code>) compared to one of its neighbor at (<code>ii_c</code>, <code>jj_c</code>). In case of instability, the function returns a two-digit number (<code>status</code>) that provides information on how the soil should avalanche. The interpretation of the two-digit number is described below.</p><p>The first digit indicates the potential presence of the bucket:</p><ul><li>1 when the first bucket layer is present.</li><li>2 when the second bucket layer is present.</li><li>3 when the two bucket layers are present.</li><li>4 when no bucket layer is present.</li></ul><p>The second digit indicates the layer where the soil should avalanche:</p><ul><li>0 when it is the terrain (no bucket is present).</li><li>1 when it is the second bucket soil layer.</li><li>2 when it is the second bucket layer.</li><li>3 when it is the first bucket soil layer.</li><li>4 when it is the first bucket layer.</li></ul><p>The combination of these two digits provides a comprehensive description of how the soil should avalanche in different scenarios.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>Not all combinations for <code>status</code> are possible. Some combinations, such as <code>41</code> or <code>23</code> are impossible.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>ii::Int64</code>: Index of the considered cell in the X direction.</li><li><code>jj::Int64</code>: Index of the considered cell in the Y direction.</li><li><code>ind::Int64</code>: Index of the considered soil layer.</li><li><code>ii_c::Int64</code>: Index of the neighboring cell in the X direction.</li><li><code>jj_c::Int64</code>: Index of the neighboring cell in the Y direction.</li><li><code>h_min::Float64</code>: Minimum allowed height for a stable configuration. [m]</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Int64</code>: Two-digit number indicating how the soil should avalanche.          <code>0</code> is returned if the soil column is stable.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

status = _check_unstable_body_cell(out, 10, 14, 1, 10, 15, -0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/relax.jl#L522-L575">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._check_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T}, Tuple{SimOut{B, I, T}, I, I, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._check_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T}, Tuple{SimOut{B, I, T}, I, I, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._check_unstable_terrain_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_check_unstable_terrain_cell(
    out::SimOut{B,I,T}, ii_c::I, jj_c::I, h_min::T, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function checks the stability of a soil column in <code>terrain</code> compared to one of its neighbor (<code>ii_c</code>, <code>jj_c</code>). In case of instability, the function returns a two-digit number (<code>status</code>) that provides information on how the soil should avalanche. The interpretation of the two-digit number is described below.</p><p>The first digit indicates the potential presence of the bucket:</p><ul><li>1 when the first bucket layer is present.</li><li>2 when the second bucket layer is present.</li><li>3 when the two bucket layers are present.</li><li>4 when no bucket layer is present.</li></ul><p>The second digit indicates the layer where the soil should avalanche:</p><ul><li>0 when it is the terrain (no bucket is present).</li><li>1 when it is the second bucket soil layer.</li><li>2 when it is the second bucket layer.</li><li>3 when it is the first bucket soil layer.</li><li>4 when it is the first bucket layer.</li></ul><p>The combination of these two digits provides a comprehensive description of how the soil should avalanche in different scenarios.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>Not all combinations for <code>status</code> are possible. Some combinations, such as <code>41</code> or <code>23</code> are impossible.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>ii_c::Int64</code>: Index of the neighboring cell in the X direction.</li><li><code>jj_c::Int64</code>: Index of the neighboring cell in the Y direction.</li><li><code>h_min::Float64</code>: Minimum allowed height for a stable configuration. [m]</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Int64</code>: Two-digit number indicating how the soil should avalanche.          <code>0</code> is returned if the soil column is stable.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

status = _check_unstable_terrain_cell(out, 10, 15, -0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/relax.jl#L342-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._locate_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}, Tuple{SimOut{B, I, T}, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._locate_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}, Tuple{SimOut{B, I, T}, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._locate_unstable_terrain_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_locate_unstable_terrain_cell(
    out::SimOut{B,I,T}, dh_max::T, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function locates all the cells in <code>terrain</code> that have a height difference larger than <code>dh_max</code> with at least one neighboring cell. Such height difference may indicate that the soil column is unstable. However, it is important to note that this condition is not necessarily indicative of an actual soil instability, as a bucket or the soil resting on it could be supporting the soil column.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>dh_max::Float64</code>: Maximum height difference allowed between two neighboring cells. [m]</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>: Collection of cells indices that are possibly unstable.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

unstable_cells = _locate_unstable_terrain_cell(out, 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/relax.jl#L282-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._relax_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._relax_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._relax_body_soil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_relax_body_soil!(
    out::SimOut{B,I,T}, grid::GridParam{I,T}, bucket::BucketParam{T},
    sim::SimParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil in <code>body_soil</code> towards a state closer to equilibrium. The soil stability is determined by the <code>repose_angle</code>. If the slope formed by two neighboring soil columns exceeds the <code>repose_angle</code>, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.</p><p>By convention, this function only checks the stability of the soil in the four adjacent cells:                      ↑                    ← O →                      ↓</p><p>The diagonal directions are not checked for simplicity and performance reasons.</p><p>This function only moves the soil when the following conditions are met:</p><p>(1) The soil column in the neighboring cell is low enough. (2) There is space on the top of the neighboring soil column.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li><li><code>sim::SimParam{Int64,Float64}</code>: Struct that stores information related to the                                 simulation.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)
sim = SimParam(0.85, 3, 4)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_relax_body_soil!(out, grid, bucket, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/relax.jl#L154-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._relax_terrain!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._relax_terrain!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._relax_terrain!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_relax_terrain!(
    out::SimOut{B,I,T}, grid::GridParam{I,T}, bucket::BucketParam{T},
    sim::SimParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil in <code>terrain</code> towards a state closer to equilibrium. The soil stability is determined by the <code>repose_angle</code>. If the slope formed by two neighboring soil columns exceeds the <code>repose_angle</code>, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.</p><p>By convention, this function only checks the stability of the soil in the four adjacent cells:                      ↑                    ← O →                      ↓</p><p>The diagonal directions are not checked for simplicity and performance reasons.</p><p>This function only moves the soil when the following conditions are met:</p><p>(1) The soil column in the neighboring cell is low enough. (2) Either:         (a) The bucket is not on the soil, meaning there is space between the <code>terrain</code> and             the bucket, or there is no bucket.         (b) The bucket is on the <code>terrain</code>, but the combination of the bucket and bucket             soil is not high enough to prevent soil avalanche.</p><p>In case (2a), the soil will avalanche on the <code>terrain</code>, while in case (2b), the soil will avalanche on the bucket.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li><li><code>sim::SimParam{Int64,Float64}</code>: Struct that stores information related to the                                 simulation.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)
sim = SimParam(0.85, 3, 4)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_relax_terrain!(out, grid, bucket, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/relax.jl#L9-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._relax_unstable_body_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, Array{BodySoil{I, T}, 1}, T, I, I, I, I, I, I, GridParam{I, T}, BucketParam{T}}, Tuple{SimOut{B, I, T}, I, Array{BodySoil{I, T}, 1}, T, I, I, I, I, I, I, GridParam{I, T}, BucketParam{T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._relax_unstable_body_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, Array{BodySoil{I, T}, 1}, T, I, I, I, I, I, I, GridParam{I, T}, BucketParam{T}}, Tuple{SimOut{B, I, T}, I, Array{BodySoil{I, T}, 1}, T, I, I, I, I, I, I, GridParam{I, T}, BucketParam{T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._relax_unstable_body_cell!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_relax_unstable_body_cell!(
    out::SimOut{B,I,T}, status::I, new_body_soil_pos::Vector{BodySoil{I,T}}, dh_max::T,
    nn::I, ii::I, jj::I, ind::I, ii_c::I, jj_c::I, grid::GridParam{I,T},
    bucket::BucketParam{T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil from the soil layer <code>ind</code> of <code>body_soil</code> at (<code>ii</code>, <code>jj</code>) to the soil column in (<code>ii_c</code>, <code>jj_c</code>). The precise movement depends on the <code>status</code> number as explained in the <code>_check_unstable_body_cell</code> function.</p><p>The soil is moved such that the slope formed by the two neighboring soil columns is equal to the <code>repose_angle</code>, provided that the bucket is not preventing this configuration.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>It is assumed that the given <code>status</code> is accurate, so no extra checks are present.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>status::Int64</code>: Two-digit number indicating how the soil should avalanche.</li><li><code>new_body_soil_pos::Vector{BodySoil{Int64,Float64}}</code>: Queue to append new <code>body_soil_pos</code>.</li><li><code>dh_max::Float64</code>: Maximum height difference allowed between two neighboring cells. [m]</li><li><code>nn::Int64</code>: Index of the considered soil in <code>body_soil_pos</code>.</li><li><code>ii::Int64</code>: Index of the considered cell in the X direction.</li><li><code>jj::Int64</code>: Index of the considered cell in the Y direction.</li><li><code>ind::Int64</code>: Index of the considered soil layer.</li><li><code>ii_c::Int64</code>: Index of the neighboring cell in the X direction.</li><li><code>jj_c::Int64</code>: Index of the neighboring cell in the Y direction.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">new_body_soil_pos = Vector{BodySoil{Int64,Float64}}()
grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_relax_unstable_body_cell!(
    out, 40, new_body_soil_pos, 0.1, 28, 5, 7, 1, 5, 6, grid, bucket
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/relax.jl#L937-L990">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._relax_unstable_terrain_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}, BucketParam{T}}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}, BucketParam{T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._relax_unstable_terrain_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}, BucketParam{T}}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}, BucketParam{T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._relax_unstable_terrain_cell!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_relax_unstable_terrain_cell!(
    out::SimOut{B,I,T}, status::I, dh_max::T, ii::I, jj::I, ii_c::I, jj_c::I,
    grid::GridParam{I,T}, bucket::BucketParam{T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil from the <code>terrain</code> at (<code>ii</code>, <code>jj</code>) to the soil column in (<code>ii_c</code>, <code>jj_c</code>). The precise movement depends on the <code>status</code> number as explained in the <code>_check_unstable_terrain_cell</code> function.</p><p>The soil is moved such that the slope formed by the two neighboring soil columns is equal to the <code>repose_angle</code>. When the bucket is preventing this configuration, the soil avalanche below the bucket to fill the space under it.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>It is assumed that the given <code>status</code> is accurate, so no extra checks are present.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>status::Int64</code>: Two-digit number indicating how the soil should avalanche.</li><li><code>dh_max::Float64</code>: Maximum height difference allowed between two neighboring cells. [m]</li><li><code>ii::Int64</code>: Index of the considered cell in the X direction.</li><li><code>jj::Int64</code>: Index of the considered cell in the Y direction.</li><li><code>ii_c::Int64</code>: Index of the neighboring cell in the X direction.</li><li><code>jj_c::Int64</code>: Index of the neighboring cell in the Y direction.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_relax_unstable_terrain_cell!(out, 131, 0.1, 10, 15, 10, 14, grid, bucket)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/relax.jl#L712-L759">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intersecting_cells/">« intersecting_cells.jl</a><a class="docs-footer-nextpage" href="../utils/">utils.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 5 May 2024 00:53">Sunday 5 May 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
