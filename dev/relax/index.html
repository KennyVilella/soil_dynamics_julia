<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>relax.jl · Soil dynamics simulator</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Soil dynamics simulator</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">types.jl</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../bucket/">bucket.jl</a></li><li><a class="tocitem" href="../body_soil/">body_soil.jl</a></li><li><a class="tocitem" href="../intersecting_cells/">intersecting_cells.jl</a></li><li class="is-active"><a class="tocitem" href>relax.jl</a></li><li><a class="tocitem" href="../utils/">utils.jl</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>relax.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>relax.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/main/docs/src/relax.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation-for-relax.jl"><a class="docs-heading-anchor" href="#Documentation-for-relax.jl">Documentation for relax.jl</a><a id="Documentation-for-relax.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-for-relax.jl" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._check_unstable_body_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._check_unstable_body_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._check_unstable_body_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_check_unstable_body_cell(
    out::SimOut{B,I,T}, ii::I, jj::I, ind::I, ii_c::I, jj_c::I, h_min::T, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function checks the stability of a soil column in the soil layer <code>ind</code> of <code>body_soil</code> at (<code>ii</code>, <code>jj</code>) compared to one of its neighbor at (<code>ii_c</code>, <code>jj_c</code>). In case of instability, the function returns a two-digit number (<code>status</code>) that provides information on how the soil should avalanche. The interpretation of the two-digit number is described below.</p><p>The first digit indicates the potential presence of the bucket:</p><ul><li>1 when the first bucket layer is present.</li><li>2 when the second bucket layer is present.</li><li>3 when the two bucket layers are present.</li><li>4 when no bucket layer is present.</li></ul><p>The second digit indicates the layer where the soil should avalanche:</p><ul><li>0 when it is the <code>terrain</code> (no bucket is present).</li><li>1 when it is the second bucket soil layer.</li><li>2 when it is the second bucket layer.</li><li>3 when it is the first bucket soil layer.</li><li>4 when it is the first bucket layer.</li></ul><p>The combination of these two digits provides a comprehensive description of how the soil should avalanche in different scenarios.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>Not all combinations for <code>status</code> are possible. Some combinations, such as <code>41</code> and <code>23</code> are impossible.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>ii::Int64</code>: Index of the considered cell in the X direction.</li><li><code>jj::Int64</code>: Index of the considered cell in the Y direction.</li><li><code>ind::Int64</code>: Index of the considered soil layer.</li><li><code>ii_c::Int64</code>: Index of the neighboring cell in the X direction.</li><li><code>jj_c::Int64</code>: Index of the neighboring cell in the Y direction.</li><li><code>h_min::Float64</code>: Minimum allowed height for a stable configuration. [m]</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>status::Int64</code>: Two-digit number indicating how the soil should avalanche.                  <code>0</code> is returned if the soil column is stable.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

status = _check_unstable_body_cell(out, 10, 14, 1, 10, 15, -0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/relax.jl#L482-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._check_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T}, Tuple{SimOut{B, I, T}, I, I, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._check_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T}, Tuple{SimOut{B, I, T}, I, I, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._check_unstable_terrain_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_check_unstable_terrain_cell(
    out::SimOut{B,I,T}, ii_c::I, jj_c::I, h_min::T, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function checks the stability of a soil column in <code>terrain</code> compared to one of its neighbor (<code>ii_c</code>, <code>jj_c</code>). In case of instability, the function returns a three-digit number (<code>status</code>) that provides information on how the soil should avalanche. The interpretation of the three-digit number is described below.</p><p>The first digit indicates the potential presence of the bucket:</p><ul><li>1 when the first bucket layer is present.</li><li>2 when the second bucket layer is present.</li><li>3 when the two bucket layers are present.</li><li>4 when no bucket layer is present.</li></ul><p>The second digit indicates the layer at the top where the soil should avalanche:</p><ul><li>0 when it is the <code>terrain</code> (no bucket is present).</li><li>1 when it is the second bucket soil layer.</li><li>2 when it is the second bucket layer.</li><li>3 when it is the first bucket soil layer.</li><li>4 when it is the first bucket layer.</li></ul><p>The third digit indicates whether the soil should avalanche below or above the bucket:</p><ul><li>0 when there is no bucket.</li><li>1 when the soil should avalanche below the bucket.</li><li>2 when the soil should avalanche on the top of the bucket.</li></ul><p>The combination of these three digits provides a comprehensive description of how the soil should avalanche in different scenarios.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>Not all combinations for <code>status</code> are possible. Some combinations, such as <code>401</code>, <code>231</code> and <code>220</code>, are impossible.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>ii_c::Int64</code>: Index of the neighboring cell in the X direction.</li><li><code>jj_c::Int64</code>: Index of the neighboring cell in the Y direction.</li><li><code>h_min::Float64</code>: Minimum allowed height for a stable configuration. [m]</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>status::Int64</code>: Three-digit number indicating how the soil should avalanche.                  <code>0</code> is returned if the soil column is stable.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

status = _check_unstable_terrain_cell(out, 10, 15, -0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/relax.jl#L321-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._locate_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}, Tuple{SimOut{B, I, T}, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._locate_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}, Tuple{SimOut{B, I, T}, T, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._locate_unstable_terrain_cell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_locate_unstable_terrain_cell(
    out::SimOut{B,I,T}, dh_max::T, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function locates all the cells in <code>terrain</code>that have a height difference larger than <code>dh_max</code> with at least one neighboring cell. Such height difference may indicate that the soil column is unstable. However, it is important to note that this condition is not necessarily indicative of an actual soil instability, as a bucket or the soil resting on it could be supporting the soil column.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>dh_max::Float64</code>: Maximum height difference allowed between two neighboring cells. [m]</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>unstable_cells::Vector{Vector{Int64}}</code>: Collection of cells indices that are possibly                                          unstable.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

unstable_cells = _locate_unstable_terrain_cell(out, 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/relax.jl#L260-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._relax_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._relax_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._relax_body_soil!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_relax_body_soil!(
    out::SimOut{B,I,T}, grid::GridParam{I,T}, sim::SimParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil in <code>body_soil</code> towards a state closer to equilibrium. The soil stability is determined by the <code>repose_angle</code>. If the slope formed by two neighboring soil columns exceeds the <code>repose_angle</code>, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.</p><p>By convention, this function only checks the stability of the soil in the four adjacent cells:                      ↑                    ← O →                      ↓</p><p>The diagonal directions are not checked for simplicity and performance reasons.</p><p>This function only moves the soil when the following conditions are met:</p><p>(1) The soil column in the neighboring cell is low enough. (2) There is space on the top of the neighboring soil column.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>This function is a work in progress.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>sim::SimParam{Int64,Float64}</code>: Struct that stores information related to the                                 simulation.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
sim = SimParam(0.85, 3, 4)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_relax_body_soil!(out, grid, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/relax.jl#L145-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._relax_terrain!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._relax_terrain!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._relax_terrain!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_relax_terrain!(
    out::SimOut{B,I,T}, grid::GridParam{I,T}, sim::SimParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil in <code>terrain</code> towards a state closer to equilibrium. The soil stability is determined by the <code>repose_angle</code>. If the slope formed by two neighboring soil columns exceeds the <code>repose_angle</code>, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.</p><p>By convention, this function only checks the stability of the soil in the four adjacent cells:                      ↑                    ← O →                      ↓</p><p>The diagonal directions are not checked for simplicity and performance reasons.</p><p>This function only moves the soil when the following conditions are met:</p><p>(1) The soil column in the neighboring cell is low enough. (2) Either:         (a) The bucket is not on the soil, meaning there is space between the <code>terrain</code> and             the bucket, or there is no bucket.         (b) The bucket is on the <code>terrain</code>, but the combination of the bucket and bucket             soil is not high enough to prevent soil avalanche.</p><p>In case (2a), the soil will avalanche on the <code>terrain</code>, while in case (2b), the soil will avalanche on the bucket.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>sim::SimParam{Int64,Float64}</code>: Struct that stores information related to the                                 simulation.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
sim = SimParam(0.85, 3, 4)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_relax_terrain!(out, grid, sim)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/relax.jl#L9-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._relax_unstable_body_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, Array{Vector{I}, 1}, T, I, I, I, I, I, GridParam{I, T}}, Tuple{SimOut{B, I, T}, I, Array{Vector{I}, 1}, T, I, I, I, I, I, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._relax_unstable_body_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, Array{Vector{I}, 1}, T, I, I, I, I, I, GridParam{I, T}}, Tuple{SimOut{B, I, T}, I, Array{Vector{I}, 1}, T, I, I, I, I, I, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._relax_unstable_body_cell!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_relax_unstable_body_cell!(
    out::SimOut{B,I,T}, status::I, new_body_soil_pos::Vector{Vector{I}}, dh_max::T,
    ii::I, jj::I, ind::I, ii_c::I, jj_c::I, grid::GridParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil from the soil layer <code>ind</code> of <code>body_soil</code> at (<code>ii</code>, <code>jj</code>) to the soil column in (<code>ii_c</code>, <code>jj_c</code>). The precise movement depends on the <code>status</code> number as explained in the <code>_check_unstable_body_cell</code> function.</p><p>The soil is moved such that the slope formed by the two neighboring soil columns is equal to the <code>repose_angle</code>, provided that the bucket is not preventing this configuration.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>It is assumed that the given <code>status</code> is accurate, so no extra checks are present.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>status::Int64</code>: Three-digit number indicating how the soil should avalanche.</li><li><code>new_body_soil_pos::Vector{Vector{Int64}}</code>: Queue to append new body<em>soil</em>pos.</li><li><code>dh_max::Float64</code>: Maximum height difference allowed between two neighboring cells. [m]</li><li><code>ii::Int64</code>: Index of the considered cell in the X direction.</li><li><code>jj::Int64</code>: Index of the considered cell in the Y direction.</li><li><code>ind::Int64</code>: Index of the considered soil layer.</li><li><code>ii_c::Int64</code>: Index of the neighboring cell in the X direction.</li><li><code>jj_c::Int64</code>: Index of the neighboring cell in the Y direction.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">new_body_soil_pos = Vector{Vector{Int64}}()
grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_relax_unstable_body_cell!(out, 40, new_body_soil_pos, 0.1, 10, 15, 1, 10, 14, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/relax.jl#L794-L836">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._relax_unstable_terrain_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._relax_unstable_terrain_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._relax_unstable_terrain_cell!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_relax_unstable_terrain_cell!(
    out::SimOut{B,I,T}, status::I, dh_max::T, ii::I, jj::I, ii_c::I, jj_c::I,
    grid::GridParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function moves the soil from the <code>terrain</code> at (<code>ii</code>, <code>jj</code>) to the soil column in (<code>ii_c</code>, <code>jj_c</code>). The precise movement depends on the <code>status</code> number as explained in the <code>_check_unstable_terrain_cell</code> function.</p><p>The soil is moved such that the slope formed by the two neighboring soil columns is equal to the <code>repose_angle</code>. When the bucket is preventing this configuration, the soil avalanche below the bucket to fill the space under it.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>It is assumed that the given <code>status</code> is accurate, so no extra checks are present.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>status::Int64</code>: Three-digit number indicating how the soil should avalanche.</li><li><code>dh_max::Float64</code>: Maximum height difference allowed between two neighboring cells. [m]</li><li><code>ii::Int64</code>: Index of the considered cell in the X direction.</li><li><code>jj::Int64</code>: Index of the considered cell in the Y direction.</li><li><code>ii_c::Int64</code>: Index of the neighboring cell in the X direction.</li><li><code>jj_c::Int64</code>: Index of the neighboring cell in the Y direction.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_relax_unstable_terrain_cell!(out, 131, 0.1, 10, 15, 10, 14, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/a1418884e363cdf0ac34f56d4b0a8cf03c741003/src/relax.jl#L656-L696">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intersecting_cells/">« intersecting_cells.jl</a><a class="docs-footer-nextpage" href="../utils/">utils.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 18 July 2023 07:13">Tuesday 18 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
