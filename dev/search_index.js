var documenterSearchIndex = {"docs":
[{"location":"utils/#Documentation-for-utils.jl","page":"utils.jl","title":"Documentation for utils.jl","text":"","category":"section"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"Modules = [SoilDynamics]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"utils/#SoilDynamics.calc_normal-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T<:Float64","page":"utils.jl","title":"SoilDynamics.calc_normal","text":"calc_normal(a::Vector{T}, b::Vector{T}, c::Vector{T}) where {T<:Float64}\n\nThis function calculates the unit normal vector of a plane formed by three points using the right-hand rule.\n\nNote\n\nThe input order of the points is important as it determines the sign of the unit normal vector based on the right-hand rule.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of the first point of the plane. [m]\nb::Vector{Float64}: Cartesian coordinates of the second point of the plane. [m]\nc::Vector{Float64}: Cartesian coordinates of the third point of the plane. [m]\n\nOutputs\n\nVector{T}: Unit normal vector of the provided plane. [m]\n\nExample\n\na = [0.0, 0.0, 0.0]\nb = [1.0, 0.5, 0.23]\nc = [0.1, 0.2, -0.5]\n\nunit_normal = calc_normal(a, b, c)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#Documentation-for-bucket.jl","page":"bucket.jl","title":"Documentation for bucket.jl","text":"","category":"section"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"Modules = [SoilDynamics]\nPages   = [\"bucket.jl\"]","category":"page"},{"location":"bucket/#SoilDynamics._calc_bucket_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}}, Tuple{Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, T}, Tuple{Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, T, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_bucket_pos","text":"_calc_bucket_pos(\n    position::Vector{T}, ori::Quaternion{T}, grid::GridParam{I,T},\n    bucket::BucketParam{I,T}, step_bucket_grid::T=0.5, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function determines all the cells where the bucket is located. The bucket position is calculated based on its reference pose stored in the bucket struct, as well as the provided position (position) and orientation (ori). position and ori are used to apply the appropriate translation and rotation to the bucket relative to its reference pose. The center of rotation is assumed to be the bucket origin. The orientation is provided using the quaternion definition.\n\nNote\n\nThis function is intended for internal use only.\nThis function is a work in progress.\n\nInputs\n\nposition::Vector{Float64}: Cartesian coordinates of the bucket origin. [m]\nori::Quaternion{Float64}: Orientation of the bucket. [Quaternion]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nbucket::BucketParam{Float64}: Struct that stores information related to the                                 bucket object.\nstep_bucket_grid::Float64: Spatial increment used to decompose the edges of the bucket.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices where the bucket is located.                          Result is sorted and duplicates have been removed.\n\nExample\n\nposition = [0.5, 0.3, 0.4]\nori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\nbucket = BucketParam(o, j, b, t, 0.5)\n\n_calc_bucket_pos(position, ori, grid, bucket)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_line_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, T, GridParam{I, T}}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_line_pos","text":"_calc_line_pos(\n    a::Vector{T}, b::Vector{T}, delta::T, grid::GridParam{I,T}\n) where {I<:Int64,T<:Float64}\n\nThis function determines all the cells that lie on a straight line between two Cartesian coordinates.\n\nFor the sake of accuracy, the line is divided into smaller segments using a spatial increment delta.\n\nThe coordinates of each sub-point (ab_i) along the line can then be calculated as\n\n    ab_i = a + ab * i * delta / norm(ab)\n\nwhere i is the increment number and ab = b - a. The Cartesian coordinates can then be converted into indices\n\n    ab_i_ind = ab_i / cell_size + grid_half_length + 1\n\nFinally, the floating-point values are rounded to obtain the cell indices in the X, Y, Z directions. As the center of each cell is considered to be on the center of the top surface, round should be used for getting the cell indices in the X and Y direction, while ceil should be used for the Z direction.\n\nNote\n\nThis function is intended for internal use only.\nWhen the line follows a cell border, the exact location of the line becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of the first extremity of the line. [m]\nb::Vector{Float64}: Cartesian coordinates of the second extremity of the line. [m]\ndelta::Float64: Spatial increment used to decompose the line. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nline_pos::Vector{Vector{Int64}}: Collection of cells indices where the line is located.                                    Result is not sorted and duplicates should be expected.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.5, 0.7]\nb = [0.7, 0.8, -0.3]\n\nline_pos = _calc_line_pos(a, b, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_rectangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_rectangle_pos","text":"_calc_rectangle_pos(\n    a::Vector{T}, b::Vector{T}, c::Vector{T}, d::Vector{T},\n    delta::T, grid::GridParam{I,T}, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function determines the cells where a rectangle surface is located. The rectangle is defined by providing the Cartesian coordinates of its four vertices in the proper order.\n\nTo optimize performance, the function iterates over a portion of the horizontal grid where the rectangle is located. For each cell, the function calculates the height of the plane formed by the rectangle at the top right corner of the cell. If the cell is within the rectangle area, the calcualted height is added to the results for the four neighboring cells.\n\nThis method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.\n\nHowever, this approach does not work when the rectangle is perpendicular to the XY plane. To handle this case, the function uses the _calc_line_pos function to include the cells that lie on the four edges of the rectangle.\n\nNote\n\nThis function is intended for internal use only.\nThe iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.\nNot all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.\nWhen the rectangle follows a cell border, the exact location of the rectangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nb::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nc::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nd::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\ndelta::Float64: Spatial increment used to decompose the edges of the rectangle. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices where the rectangle is located.                          Result is not sorted and duplicates may be present.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.0, 0.7]\nb = [0.0, 1.0, 0.7]\nc = [0.0, 1.0, 0.9]\nd = [1.0, 0.0, 0.9]\n\nrect_pos = _calc_rectangle_pos(a, b, c, d, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_triangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_triangle_pos","text":"_calc_triangle_pos(\n    a::Vector{T}, b::Vector{T}, c::Vector{T},\n    delta::T, grid::GridParam{I,T}, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function determines the cells where a triangle surface is located. The triangle is defined by providing the Cartesian coordinates of its three vertices in the proper order.\n\nTo optimize performance, the function iterates over a portion of the horizontal grid where the triangle is located. For each cell, the function calculates the height of the plane formed by the triangle at the top right corner of the cell. If the cell is within the triangle area, the calcualted height is added to the results for the four neighboring cells.\n\nThis method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.\n\nHowever, this approach does not work when the triangle is perpendicular to the XY plane. To handle this case, the function uses the _calc_line_pos function to include the cells that lie on the three edges of the triangle.\n\nNote\n\nThis function is intended for internal use only.\nThe iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.\nNot all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.\nWhen the triangle follows a cell border, the exact location of the triangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\nb::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\nc::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\ndelta::Float64: Spatial increment used to decompose the edges of the triangle. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices where the triangle is located.                          Result is not sorted and duplicates may be present.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.0, 0.7]\nb = [0.0, 1.0, 0.7]\nc = [0.0, 1.0, 0.9]\n\ntri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._decompose_vector_rectangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._decompose_vector_rectangle","text":"_decompose_vector_rectangle(\n    ab_ind::Vector{T}, ad_ind::Vector{T}, a_ind::Vector{T},\n    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function performs a vector decomposition on a portion of the horizontal plane where a rectangle ABCD is located. The position of the rectangle is defined by its edges AB and AD , while the specified area extends over [area_min_x, area_min_x + area_length_x] on the X direction and [area_min_y, area_min_y + area_length_y] on the Y direction.\n\nFor each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AD. Let O be the name of a cell, it can then be decomposed as\n\nAO = c_ab * AB + c_ad * AD.\n\nThis decomposition leads to a system of 2 equations with 2 unknowns (cab and cad)\n\nAO[1] = cab * AB[1] + cad * AD[1] {1}, AO[2] = cab * AB[2] + cad * AD[2] {2}.\n\nOne may note that AB[1] * {2} - AB[2] * {1} implies that\n\nAB[1] * AO[2] - AB[2] * AO[1] = cad * AD[2] * AB[1] - cad * AD[1] * AB[2]\n\nthat can be further rewritten as\n\nc_ad = (AB[1] * AO[2] - AB[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).\n\nSimilarly, AD[1] * {2} - AD[2] * {1} implies that\n\nc_ab = -(AD[1] * AO[2] - AD[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).\n\nThis decomposition allows us to determine whether the cell O is inside the rectangle area, since this requires cab and cad to be between 0 and 1.\n\nNote\n\nThis function is intended for internal use only.\nBy convention, the decomposition is done at the top right corner of each cell.\n\nInputs\n\nab_ind::Vector{Float64}: Indices representing the edge AB of the rectangle.\nad_ind::Vector{Float64}: Indices representing the edge AD of the rectangle.\na_ind::Vector{Float64}: Indices of the vertex A from which the edges AB and AD start.\narea_min_x::Int64: Minimum index in the X direction of the specified area.\narea_min_y::Int64: Minimum index in the Y direction of the specified area.\narea_length_x::Int64: Number of grid elements in the X direction of the specified area.\narea_length_y::Int64: Number of grid elements in the Y direction of the specified area.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nc_ab::Matrix{Float64}: Results of the vector decomposition in terms of the AB component.\nc_ad::Matrix{Float64}: Results of the vector decomposition in terms of the AD component.\nin_rectangle::Matrix{Bool}: Indicates whether the cell is inside the rectangle area.\nn_cell::Int64: Number of cells inside the rectangle area.\n\nExample\n\nab_ind = [0, 4, 0]\nad_ind = [3, 0, 0]\na_ind = [10, 8, 25]\n\nc_ab, c_ad, in_rectangle, n_cell = _decompose_vector_rectangle(\n    ab_ind, ad_ind, a_ind, 15, 12, 8, 7\n)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._decompose_vector_triangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._decompose_vector_triangle","text":"_decompose_vector_triangle(\n    ab_ind::Vector{T}, ac_ind::Vector{T}, a_ind::Vector{T},\n    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function performs a vector decomposition on a portion of the horizontal plane where a triangle ABC is located. The position of the triangle is defined by its edges AB and AC , while the specified area extends over [area_min_x, area_min_x + area_length_x] on the X direction and [area_min_y, area_min_y + area_length_y] on the Y direction.\n\nFor each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AC. Let O be the name of a cell, it can then be decomposed as\n\nAO = c_ab * AB + c_ac * AC.\n\nThis decomposition leads to a system of 2 equations with 2 unknowns (cab and cac)\n\nAO[1] = cab * AB[1] + cac * AC[1] {1}, AO[2] = cab * AB[2] + cac * AC[2] {2}.\n\nOne may note that AB[1] * {2} - AB[2] * {1} implies that\n\nAB[1] * AO[2] - AB[2] * AO[1] = cac * AC[2] * AB[1] - cac * AC[1] * AB[2]\n\nthat can be further rewritten as\n\nc_ac = (AB[1] * AO[2] - AB[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).\n\nSimilarly, AC[1] * {2} - AC[2] * {1} implies that\n\nc_ab = -(AC[1] * AO[2] - AC[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).\n\nThis decomposition allows us to determine whether the cell O is inside the triangle area, since this requires cab and cac to be between 0 and 1, and the sum of cab and cac to be lower than 1.\n\nNote\n\nThis function is intended for internal use only.\nBy convention, the decomposition is done at the top right corner of each cell.\n\nInputs\n\nab_ind::Vector{Float64}: Indices representing the edge AB of the triangle.\nac_ind::Vector{Float64}: Indices representing the edge AC of the triangle.\na_ind::Vector{Float64}: Indices of the vertex A from which the edges AB and AC start.\narea_min_x::Int64: Minimum index in the X direction of the specified area.\narea_min_y::Int64: Minimum index in the Y direction of the specified area.\narea_length_x::Int64: Number of grid elements in the X direction of the specified area.\narea_length_y::Int64: Number of grid elements in the Y direction of the specified area.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nc_ab::Matrix{Float64}: Results of the vector decomposition in terms of the AB component.\nc_ac::Matrix{Float64}: Results of the vector decomposition in terms of the AC component.\nin_triangle::Matrix{Bool}: Indicates whether the cell is inside the triangle area.\nn_cell::Int64: Number of cells inside the triangle area.\n\nExample\n\nab_ind = [0, 4, 0]\nac_ind = [3, 0, 0]\na_ind = [10, 8, 25]\n\nc_ab, c_ac, in_triangle, n_cell = _decompose_vector_triangle(\n    ab_ind, ac_ind, a_ind, 15, 12, 8, 7\n)\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"types/#Documentation-for-types.jl","page":"types.jl","title":"Documentation for types.jl","text":"","category":"section"},{"location":"types/","page":"types.jl","title":"types.jl","text":"Modules = [SoilDynamics]\nPages   = [\"types.jl\"]","category":"page"},{"location":"types/#SoilDynamics.BucketParam","page":"types.jl","title":"SoilDynamics.BucketParam","text":"BucketParam{T<:Float64}\n\nStore all parameters related to a bucket object.\n\nConvention\n\nThe bucket is approximated as a triangular prism\n               A ____________________ D\n              /.                     /| \n             / .                    / |  \n            /  .                   /  |\n           /   .                  /   |\n          /    .                 /    |\n         /     .                /     |\n        /      .               /      |\n       /       C . . . . . .  / . . . F\n      /      .               /        ̸\n     /     .                /       ̸\n    /    .                 /      ̸\n   /   .                  /     ̸\n  /  .                   /    ̸\n / .                    /   ̸\nB ____________________ E\nThe middle of the segment AD is referred to as the bucket \"joint\".\nThe middle of the segment CF is referred to as the bucket \"base\".\nThe middle of the segment BE is referred to as the bucket \"teeth\".\nThe surface ABED is open and referred to as the bucket \"front\".\nThe surface BCFE is a bucket wall and referred to as the bucket \"base\".\nThe surface ACFD is a bucket wall and referred to as the bucket \"back\".\nThe surface ABC is a bucket wall and referred to as the bucket \"right side\".\nThe surface DEF is a bucket wall and referred to as the bucket \"left side\".\nThe bucket has a constant width, denoted as           AD = BE = CF = width.\nThe center of rotation of the bucket is assumed to be at the bucket \"origin\" (not shown in the figure) and the bucket vertices are given relative to this origin.\nThe provided coordinates are assumed to be the reference pose of the bucket, from which the bucket pose is calculated throughout the code.\n\nFields\n\nj_pos_init::Vector{Float64}: Cartesian coordinates of the bucket joint in its                                reference pose. [m]\nb_pos_init::Vector{Float64}: Cartesian coordinates of the bucket base in its                                reference pose. [m]\nt_pos_init::Vector{Float64}: Cartesian coordinates of the bucket teeth in its                                reference pose. [m]\nwidth::Float64: Width of the bucket. [m]\n\nInner constructor\n\nBucketParam(\n    o_pos_init::Vector{T}, j_pos_init::Vector{T}, b_pos_init::Vector{T},\n    t_pos_init::Vector{T}, width::T\n) where {T<:Float64}\n\nCreate a new instance of BucketParam using the reference positions of the bucket origin, joint, base, and teeth as well as the bucket width. The position of the bucket joint, base, and teeth are given relative to the position of the bucket origin.\n\nRequirements:\n\nAll provided Cartesian coordinates should be a vector of size 3.\nThe bucket joint, base and teeth should have strictly different location.\nThe bucket width should be greater than zero.\n\nExample\n\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\n\nbucket = BucketParam(o, j, b, t, 0.5)\n\nThis would create a bucket ABCDEF with its center of rotation at the bucket joint and with A = [0.0, -0.25, 0.0], B = [1.0, -0.25, -0.5], C = [0.0, -0.25, -0.5] D = [0.0, 0.25, 0.0], E = [1.0, 0.25, -0.5], F = [0.0, 0.25, -0.5].\n\n\n\n\n\n","category":"type"},{"location":"types/#SoilDynamics.GridParam","page":"types.jl","title":"SoilDynamics.GridParam","text":"GridParam{I<:Int64,T<:Float64}\n\nStore all parameters related to the simulation grid.\n\nConvention\n\nThe simulation grid is centred at 0, that is, if the extent of the grid is 10.0, the grid would then extend from -5.0 to 5.0, this applies to all direction.\nThe grid is composed of regular 3D cells\n          H-----------G\n         /           /|\n        /     O     / |\n       /           /  |\n      E-----------F   C\n      |           |  /\n      |           | /\n      |           |/ \n      A-----------B\nThe cells have the same size in both lateral direction           AB = BC = CD = DA = EF = FG = GH = HE, while their height can potentially be lower           AE = BF = CG = DH <= AB.\nThe center of each cell (O) is considered to be at the center of the top surface.\nThe considered reference frame follows the right-hand rule, with the Z direction pointing upward.\n\nFields\n\nhalf_length_x::Int64: Number of grid elements in the positive (or negative) X direction.\nhalf_length_y::Int64: Number of grid elements in the positive (or negative) Y direction.\nhalf_length_z::Float64: Number of grid elements in the positive (or negative) Z                           direction. Note that it is a Float.\ncell_size_xy::Float64: Size of the cells in the X and Y direction. [m]\ncell_size_z::Float64: Height of the cells in the Z direction. [m]\ncell_area::Float64: Surface area of one cell in the horizontal plane. [m^2]\ncell_volume::Float64: Volume of one cell. [m^3]\n\nInner constructor\n\nGridParam(\n    grid_size_x::T, grid_size_y::T, grid_size_z::T, cell_size_xy::T,\n    cell_size_z::T=cell_size_xy\n) where {T<:Float64}\n\nCreate a new instance of GridParam using the grid size in [m]. The actual size of the grid would be:\n\n[-gridsizex, gridsizex] in the X direction.\n[-gridsizey, gridsizey] in the Y direction.\n[-gridsizez, gridsizez] in the Z direction.\n\nRequirements:\n\nAll inputs should be greater than zero.\ncellsizexy should be lower than or equal to gridsizex and gridsizey.\ncellsizez should be lower than or equal to gridsizez.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\n\nThis would create a grid of size [-4, 4] in the X direction, [-4, 4] in the Y direction, [-3, 3] in the Z direction, and with cells of size 0.05 x 0.05 x 0.01 in the XYZ direction.\n\n\n\n\n\n","category":"type"}]
}
