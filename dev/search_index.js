var documenterSearchIndex = {"docs":
[{"location":"intersecting_cells/#Documentation-for-intersecting_cells.jl","page":"intersecting_cells.jl","title":"Documentation for intersecting_cells.jl","text":"","category":"section"},{"location":"intersecting_cells/#Introductory-remarks","page":"intersecting_cells.jl","title":"Introductory remarks","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"After updating the position of the bucket and the soil resting on the bucket, it is possible that some soil cells are located in the same position as a bucket wall, while it is obviously physically impossible to have both soil and the bucket at the same position. These soil cells are referred to as intersecting cells in the simulator.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"The purpose of the functions in this file is to move these soil cells following a set of rules to ensure a physically valid simulation. The process involves two main steps: moving intersecting cells resting on the bucket and moving intersecting cells from the terrain. The order of these steps is crucial, as the movement of intersecting cells resting on the bucket can create new intersecting cells in the terrain.","category":"page"},{"location":"intersecting_cells/#Movement-of-soil-cells-on-the-bucket-intersecting-with-the-bucket","page":"intersecting_cells.jl","title":"Movement of soil cells on the bucket intersecting with the bucket","text":"","category":"section"},{"location":"intersecting_cells/#General-description","page":"intersecting_cells.jl","title":"General description","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"This step focuses on relocating intersecting soil cells that are resting on the bucket. The process involves selecting randomly one of the eight directions surrounding the intersecting cells and investigating whether the soil can be moved in that direction. The algorithm explores positions incrementally farther from the intersecting cells until all the soil has been moved or a bucket wall blocks the movement. If a bucket wall blocks the movement, another direction is selected for investigation. In rare cases where not all soil can be moved after exploring all eight directions, a warning is issued, and the excess soil simply disappears. However, this edge case should not occur in normal scenarios.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"Note: ","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"The investigated directions are randomized in order to avoid asymmetrical results.\nThere are necessarily two bucket layers where the intersecting soil cells are located.","category":"page"},{"location":"intersecting_cells/#Description-of-the-different-cases","page":"intersecting_cells.jl","title":"Description of the different cases","text":"","category":"section"},{"location":"intersecting_cells/#No-bucket-is-present","page":"intersecting_cells.jl","title":"No bucket is present","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"In this case, the intersecting soil cells are simply moved to the terrain.","category":"page"},{"location":"intersecting_cells/#One-bucket-layer","page":"intersecting_cells.jl","title":"One bucket layer","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"Three different cases are possible, as illustrated in the vertical slice diagram below:","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(Image: Intersecting bucket soil cells)","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(a) In this case, there is an open space below the bucket layer, and the remaining intersecting soil cells are moved to the terrain. This movement is independent of the available space below the bucket. If there is insufficient space, the soil is still moved, and the newly created intersecting soil cells will be addressed in the subsequent step.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(b) In this case, the remaining intersecting soil cells are moved to the top of the bucket layer. This movement is independent of whether soil is present on this bucket layer.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(c) In this case, the bucket layer in the new position extends over the two bucket layers from the previous position, creating a wall that prevents soil movement. The exploration in this direction is therefore halted.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"Note that in this case the investigation of the considered direction will necessarily stop, either because of the presence of a bucket wall or because all the soil could be moved. That also means that the previous position has necessarily two bucket layers.","category":"page"},{"location":"intersecting_cells/#Two-bucket-layers","page":"intersecting_cells.jl","title":"Two bucket layers","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"Four different cases are possible, as illustrated in the vertical slice diagram below:","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(Image: Intersecting bucket soil cells)","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(a) In this case, the soil fully fills the space between the two bucket layers in the new position. No soil is moved to this position, but the exploration in this direction can continue.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(b) In this case, some space is available between the two bucket layers. The intersecting cells are moved to the available space, and the exploration in this direction continues.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(c) In this case, the combination of the bucket soil and the bottom bucket layer in the new position extends over the two bucket layers from the previous position. The intersecting cells are still moved to the available space, and the exploration in this direction continues.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(d) In this case, enough space is available between the two bucket layers to accommodate all the intersecting soil cells. The remaining intersecting cells are moved to this position.","category":"page"},{"location":"intersecting_cells/#Movement-of-soil-cells-on-the-terrain-intersecting-with-the-bucket","page":"intersecting_cells.jl","title":"Movement of soil cells on the terrain intersecting with the bucket","text":"","category":"section"},{"location":"intersecting_cells/#General-description-2","page":"intersecting_cells.jl","title":"General description","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"This step focuses on relocating intersecting soil cells that are present in the terrain and intersect with the bucket. The algorithm investigates the eight cells surrounding the intersecting cells in a randomized order to determine if soil can be moved to those positions. If there is insufficient space for all the soil, the algorithm incrementally explores the eight directions farther from the intersecting soil column until all the soil has been relocated.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"Note:","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"The investigated directions are randomized in order to avoid asymmetrical results.\nSoil is necessarily moved to the terrain. The digging is therefore a two-step process. Intersecting cells are first moved to the terrain just outside the bucket, then avalanche on the bucket during the relaxation step.","category":"page"},{"location":"intersecting_cells/#Description-of-the-different-cases-2","page":"intersecting_cells.jl","title":"Description of the different cases","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"Three different cases are possible, as illustrated in the vertical slice diagram below:","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(Image: Intersecting terrain soil cells)","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(a) In this case, no bucket is present in the new position, and all the soil is moved to that position. This is done regardless of whether the bucket is buried deep underground.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(b) In this case, no space is available below the bucket, so no movement is made.","category":"page"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"(c) In this case, some space is available below the bucket, and soil is moved to that position to fill the gap.","category":"page"},{"location":"intersecting_cells/#Concluding-remarks","page":"intersecting_cells.jl","title":"Concluding remarks","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"When the simulator would have the ability to handle multiple buckets, it may be necessary to handle the movement of soil resting on a bucket that intersects with a different bucket separately. Additionally, the case where a different bucket blocks the movement of soil to the terrain would need to be addressed.","category":"page"},{"location":"intersecting_cells/#API","page":"intersecting_cells.jl","title":"API","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"Modules = [SoilDynamics]\nPages   = [\"intersecting_cells.jl\"]","category":"page"},{"location":"intersecting_cells/#SoilDynamics._locate_intersecting_cells-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._locate_intersecting_cells","text":"_locate_intersecting_cells(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function identifies all the soil cells in the terrain that intersect with the bucket.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices from the terrain intersecting with                          the bucket.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_locate_intersecting_cells(out)\n\n\n\n\n\n","category":"method"},{"location":"intersecting_cells/#SoilDynamics._move_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._move_body_soil!","text":"_move_body_soil!(\n    out::SimOut{B,I,T}, ind_p::I, ii_p::I, jj_p::I, max_h::T, ii_n::I, jj_n::I,\n    h_soil::T, wall_presence::B, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function tries to move the soil cells resting on the bucket layer ind_p at the location (ii_p, jj_p) to a new location at (ii_n, jj_n).\n\nThis function can be separated into three main scenarios:\n\nIf all the soil can be moved to the new location (either on the terrain or on the bucket), the soil is moved and the value of h_soil is set to zero.\nIf a bucket wall is blocking the movement, the wall_presence parameter is set to true.\nIf there is insufficient space to move all the soil but no bucket wall is blocking the movement, the function updates the values for the new location and adjusts h_soil accordingly.\n\nThis function is designed to be used iteratively by _move_intersecting_body_soil! until all intersecting soil cells are moved.\n\nNote\n\nThis function is intended for internal use only.\nBy convention, the soil can be moved from the bucket to the terrain even if the bucket is underground.\nIn cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the _move_intersecting_body! function.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nind_p::Int64: Index of the previous considered bucket layer.\nii_p::Int64: Index of the previous considered position in the X direction.\njj_p::Int64: Index of the previous considered position in the Y direction.\nmax_h::Float64: Maximum height authorized for the movement. [m]\nii_n::Int64: Index of the new considered position in the X direction.\njj_n::Int64: Index of the new considered position in the Y direction.\nh_soil::Float64: Height of the soil column left to be moved. [m]\nwall_presence::Bool: Indicates whether a bucket wall is blocking the movement.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nind_p::Int64: Index of the new considered bucket layer.\nii_p::Int64: Index of the new considered position in the X direction.\njj_p::Int64: Index of the new considered position in the Y direction.\nh_soil::Float64: Height of the soil column left to be moved. [m]\nwall_presence::Bool: Indicates whether a bucket wall is blocking the movement.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n ind_p, ii_p, jj_p, h_soil, wall_presence = _move_body_soil!(\n     out, 1, 10, 15, 0.2, 10, 16, 0.2, true\n )\n\n\n\n\n\n","category":"method"},{"location":"intersecting_cells/#SoilDynamics._move_intersecting_body!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._move_intersecting_body!","text":"_move_intersecting_body!(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil cells in the terrain that intersect with a bucket. It checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces. If there is insufficient space for all the soil, it incrementally checks the eight directions farther from the intersecting soil column until all the soil has been moved. The process can be illustrated as follows\n\n             ↖   ↑   ↗\n               ↖ ↑ ↗\n             ← ← O → →\n               ↙ ↓ ↘\n             ↙   ↓   ↘\n\nNote\n\nThis function is intended for internal use only.\nThe order in which the directions are checked is randomized in order to avoid asymmetrical results.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_move_intersecting_body!(out)\n\n\n\n\n\n","category":"method"},{"location":"intersecting_cells/#SoilDynamics._move_intersecting_body_soil!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._move_intersecting_body_soil!","text":"_move_intersecting_body_soil!(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil cells resting on the bucket that intersect with another bucket layer. It checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces.\n\nThe algorithm follows an incremental approach, checking directions farther from the  intersecting soil column until it reaches a bucket wall blocking the movement or until all the soil has been moved. If the movement is blocked by a bucket wall, the algorithm explores another direction.\n\nIn cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the _move_intersecting_body! function.\n\nIn rare situations where there is insufficient space to accommodate all the intersecting soil, the algorithm currently handles it by allowing the excess soil to simply disappear. This compromise seems to be reasonable as long as the amount of soil disappearing remains negligible.\n\nNote\n\nThis function is intended for internal use only.\nThe order in which the directions are checked is randomized in order to avoid asymmetrical results.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_move_intersecting_body_soil!(out)\n\n\n\n\n\n","category":"method"},{"location":"intersecting_cells/#SoilDynamics._move_intersecting_cells!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._move_intersecting_cells!","text":"_move_intersecting_cells!(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves all soil cells in terrain and in body_soil that intersect with the bucket or with another soil cell.\n\nNote\n\nThis function is intended for internal use only.\n_move_intersecting_body_soil! must be called before _move_intersecting_body!, otherwise some intersecting soil cells may remain.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_move_intersecting_cells!(out)\n\n\n\n\n\n","category":"method"},{"location":"body_soil/#Documentation-for-body_soil.jl","page":"body_soil.jl","title":"Documentation for body_soil.jl","text":"","category":"section"},{"location":"body_soil/#Introductory-remarks","page":"body_soil.jl","title":"Introductory remarks","text":"","category":"section"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"The function in this file has two important purposes:","category":"page"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"Moving the soil resting on the excavator bucket following the bucket's movement.\nCollecting the locations of the bucket soil and storing them in out.body_soil_pos.","category":"page"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"While these tasks may initially appear straightforward, they are, in fact, quite complex due to the limited information available and the need to handle edge cases where soil from different locations ends up in the same position.","category":"page"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"The first task of the function is to determine the new position of the bucket soil following the bucket's movement. This process involves several steps to accurately calculate the soil's new resting position:","category":"page"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"The algorithm starts by taking the current position of the bucket where the soil is resting and calculates the corresponding position in the reference pose of the bucket.\nNext, the algorithm applies the updated bucket pose to this reference position to determine the new position where the bucket soil should now be resting.","category":"page"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"This process is necessary because the orientation of the bucket is given relative to its reference pose.","category":"page"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"The second task is to determine the appropriate bucket layer where the soil should be placed. As it is assumed that the bucket movement between two steps is less than cell_size_xy, the soil is moved to the bucket layer that is within a vertical distance of cell_size_xy from the newly calculated position. However, there can be complications, especially when cell_size_z is significantly lower than cell_size_xy. In such cases, finding the correct bucket layer with the available information may be challenging. If no bucket layer satisfies the above condition, the soil is moved to the terrain.","category":"page"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"Note that it is crucial that this function is called after _calc_bucket_pos! and that the bucket pose has not yet been updated in the BucketParam struct.","category":"page"},{"location":"body_soil/#API","page":"body_soil.jl","title":"API","text":"","category":"section"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"Modules = [SoilDynamics]\nPages   = [\"body_soil.jl\"]","category":"page"},{"location":"body_soil/#SoilDynamics._update_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"body_soil.jl","title":"SoilDynamics._update_body_soil!","text":"_update_body_soil!(\n    out::SimOut{B,I,T}, pos::Vector{T}, ori::Quaternion{T}, grid::GridParam{I,T},\n    bucket::BucketParam{T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil resting on the bucket following its movement. To do so, the movement applied to the base of the soil column is calculated and the soil is moved to this new location. It is however difficult to track accurately each bucket wall. This is currently done by looking at the height difference between the previous and new soil locations, if this height difference is lower than cell_size_xy, it is assumed to be the same bucket wall. Some errors may however be present and further testing is required. If no bucket wall is present, the soil is moved down to the terrain.\n\nThe new positions of the soil resting on the bucket are collected into out.body_soil_pos and duplicates are removed.\n\nNote\n\nThis function is intended for internal use only.\nThis function is a work in progress. Some optimization and improvements may be needed.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\npos::Vector{Float64}: Cartesian coordinates of the bucket origin. [m]\nori::Quaternion{Float64}: Orientation of the bucket. [Quaternion]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nbucket::BucketParam{Float64}: Struct that stores information related to the                                 bucket object.\n\nOutputs\n\nNone\n\nExample\n\npos = [0.5, 0.3, 0.4]\nori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\nbucket = BucketParam(o, j, b, t, 0.5)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_update_body_soil!(out, pos, ori, grid, bucket)\n\n\n\n\n\n","category":"method"},{"location":"relax/#Documentation-for-relax.jl","page":"relax.jl","title":"Documentation for relax.jl","text":"","category":"section"},{"location":"relax/#Introductory-remarks","page":"relax.jl","title":"Introductory remarks","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"The core function of the simulator is to model soil dynamics. Various models of different complexities have been developed over the years for this purpose. As this simulator focuses on performance, a simplified model is therefore employed. The model assumes that when the local slope of the soil exceeds its repose angle, the soil becomes unstable and needs to avalanche to neighboring cells to achieve a stable state where the local slope matches the repose angle. This action is referred to as \"relaxation\" in this simulator.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"This soil relaxation process consists of two main steps: terrain relaxation and bucket soil relaxation. In the terrain relaxation, the unstable soil cells on the terrain are relaxed, potentially causing avalanches onto the bucket. Similarly, in the bucket soil relaxation, the unstable soil cells on the bucket are relaxed, potentially causing avalanches onto the terrain. It is important to note that the relaxation of soil cells can sometimes trigger instability in neighboring cells. As a result, the relaxation process needs to be repeated multiple times to achieve an equilibrium state. In practice, several thousand iterations may be required to reach full equilibrium, although the overall shape of the terrain can often be obtained after just a few iterations. To balance computational efficiency and accuracy, the algorithm does not wait for a complete equilibrium state and instead stops after a set number of iterations, which can be specified by the max_iterations field of the SimParam struct. The appropriate value for max_iterations typically ranges from 3 to 20 and should be chosen based on the specific simulation requirements. It is worth noting that increasing the value of max_iterations impacts significantly the performance of the simulator.","category":"page"},{"location":"relax/#General-description","page":"relax.jl","title":"General description","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"While the detailed implementation of the relaxation process differs for terrain relaxation and bucket soil relaxation, the core algorithm remains the same and will be described in this section.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"The relaxation process consists of three steps.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"The first step is to identify potentially unstable soil cells. This initial selection is not intended to be precise but rather to exclude cells that are obviously stable. To avoid asymmetrical results, the list of potential unstable cells is randomized. The soil cells in this list are then processed iteratively.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"The second step is to check the stability of each considered soil cell in relation to its neighboring cells. By convention, relaxation is only performed in the X and Y directions, involving four adjacent cells and excluding diagonal cells. This choice is based on initial testing, which revealed that relaxing soil in 4 or 8 directions produced visually identical results. Relaxing in 8 directions allows for convergence to full equilibrium in less iterations than when relaxing in 4 directions, while requiring more computational time to perform each iteration. As a result, relaxing only in the X and Y directions produces a faster and simpler code. To avoid asymmetrical results, the order in which neighboring soil cells are checked is randomized. The result of this check is a status code consisting of two or three digits, providing a detailed indication of the condition of the soil cell.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"The third step is the actual relaxation, which occurs only if the soil cell is determined to be unstable based on the status code obtained in the previous step. The relaxation process follows the specific instructions defined by the status code. The relaxation techniques for terrain relaxation and bucket soil relaxation will be explained separately in the following sections.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"It is worth noting that the second and third steps could potentially be merged. However, separating these two steps improves code testability and maintainability.","category":"page"},{"location":"relax/#Terrain-relaxation","page":"relax.jl","title":"Terrain relaxation","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"This corresponds to the relaxation process performed by the function _relax_terrain!. Note that the meaning of the three-digit codes given by the function _check_unstable_terrain_cell and used by the function _relax_unstable_terrain_cell! is explained in the docstring of the function _check_unstable_terrain_cell. In this section, the main focus is to explain the physical reasoning behind the implementation of the _relax_unstable_terrain_cell! function.","category":"page"},{"location":"relax/#Description-of-the-different-cases","page":"relax.jl","title":"Description of the different cases","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"Mainly four different cases are possible, as illustrated in the vertical slice diagram below. Note that, for illustration purposes, it is assumed that the repose angle allows only for one cell difference between neighboring cells.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(Image: Terrain relaxation)","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(a) In this case, there is no bucket, the soil can freely avalanche to the neighboring cell, reaching a stable configuration.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(b) In this case, there is some space available below the bucket, the soil can avalanche into that position to fill the gap. Note that the soil column would still be unstable after this movement, requiring a second iteration to reach a stable configuration.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(c) In this case, there is enough space available below the bucket to reach a stable configuration.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(d) In this case, the soil can avalanche on the top of the bucket and reach a stable configuration. Note that this is the only case in the simulator where soil from the terrain can be transferred to the bucket. Consequently, all bucket soil is generated from this case.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"It is worth mentioning that the order of these cases is important, as case (d) will only occur if cases (b) and (c) are not possible.","category":"page"},{"location":"relax/#Impact-area","page":"relax.jl","title":"Impact area","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"For performance optimization, the simulator only checks for soil instability within the lateral area specified by the impact_area field of the SimOut struct. The impact_area is a union of two areas: the bucket_area, which corresponds to the lateral area where the bucket is located, and the relax_area, which corresponds to the lateral area where unstable soil has been identified in the previous step. By limiting the analysis to this specific region, the simulator achieves significant performance gains and becomes almost independent of the grid size.","category":"page"},{"location":"relax/#Bucket-soil-relaxation","page":"relax.jl","title":"Bucket soil relaxation","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"This corresponds to the relaxation process performed by the function _relax_body_soil!. Note that the meaning of the two-digit codes given by the function _check_unstable_body_cell and used by the function _relax_unstable_body_cell! is explained in the docstring of the function _check_unstable_body_cell. In this section, the main focus is to explain the physical reasoning behind the implementation of the _relax_unstable_body_cell! function.","category":"page"},{"location":"relax/#Description-of-the-different-cases-2","page":"relax.jl","title":"Description of the different cases","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"Mainly four different cases are possible, as illustrated in the vertical slice diagram below. Note that, for illustration purposes, it is assumed that the repose angle allows only for one cell difference between neighboring cells.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(Image: Bucket soil relaxation)","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(a) In this case, there is no bucket, the soil can freely avalanche to the neighboring cell, reaching a stable configuration.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(b) In this case, there is one bucket layer, the soil can freely avalanche onto the bucket, forming a stable configuration.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(c) In this case, there is one bucket layer, the soil can avalanche from one bucket layer to another, forming a stable configuration.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"(d) In this case, there are two bucket layers, the soil can avalanche to one of the two adjacent bucket layer. Note that the top bucket layer has priority in the case where the soil can avalanche to both bucket layer, while, in the case where the soil should avalanche on the bottom layer, there may not be enough space for all the soil to avalanche, leading to a final state that may not be in equilibrium.","category":"page"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"It is important to note that the presence of the bucket at the base of the soil column adds complexity to the relaxation process. There are cases where all the soil on a bucket layer can avalanche, while in other cases, only a portion of the soil may avalanche. It is crucial to handle these cases appropriately to ensure mass conservation during the relaxation process.","category":"page"},{"location":"relax/#API","page":"relax.jl","title":"API","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"Modules = [SoilDynamics]\nPages   = [\"relax.jl\"]","category":"page"},{"location":"relax/#SoilDynamics._check_unstable_body_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._check_unstable_body_cell","text":"_check_unstable_body_cell(\n    out::SimOut{B,I,T}, ii::I, jj::I, ind::I, ii_c::I, jj_c::I, h_min::T, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function checks the stability of a soil column in the soil layer ind of body_soil at (ii, jj) compared to one of its neighbor at (ii_c, jj_c). In case of instability, the function returns a two-digit number (status) that provides information on how the soil should avalanche. The interpretation of the two-digit number is described below.\n\nThe first digit indicates the potential presence of the bucket:\n\n1 when the first bucket layer is present.\n2 when the second bucket layer is present.\n3 when the two bucket layers are present.\n4 when no bucket layer is present.\n\nThe second digit indicates the layer where the soil should avalanche:\n\n0 when it is the terrain (no bucket is present).\n1 when it is the second bucket soil layer.\n2 when it is the second bucket layer.\n3 when it is the first bucket soil layer.\n4 when it is the first bucket layer.\n\nThe combination of these two digits provides a comprehensive description of how the soil should avalanche in different scenarios.\n\nNote\n\nThis function is intended for internal use only.\nNot all combinations for status are possible. Some combinations, such as 41 and 23 are impossible.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nii::Int64: Index of the considered cell in the X direction.\njj::Int64: Index of the considered cell in the Y direction.\nind::Int64: Index of the considered soil layer.\nii_c::Int64: Index of the neighboring cell in the X direction.\njj_c::Int64: Index of the neighboring cell in the Y direction.\nh_min::Float64: Minimum allowed height for a stable configuration. [m]\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nstatus::Int64: Two-digit number indicating how the soil should avalanche.                  0 is returned if the soil column is stable.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nstatus = _check_unstable_body_cell(out, 10, 14, 1, 10, 15, -0.1)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._check_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T}, Tuple{SimOut{B, I, T}, I, I, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._check_unstable_terrain_cell","text":"_check_unstable_terrain_cell(\n    out::SimOut{B,I,T}, ii_c::I, jj_c::I, h_min::T, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function checks the stability of a soil column in terrain compared to one of its neighbor (ii_c, jj_c). In case of instability, the function returns a three-digit number (status) that provides information on how the soil should avalanche. The interpretation of the three-digit number is described below.\n\nThe first digit indicates the potential presence of the bucket:\n\n1 when the first bucket layer is present.\n2 when the second bucket layer is present.\n3 when the two bucket layers are present.\n4 when no bucket layer is present.\n\nThe second digit indicates the layer at the top where the soil should avalanche:\n\n0 when it is the terrain (no bucket is present).\n1 when it is the second bucket soil layer.\n2 when it is the second bucket layer.\n3 when it is the first bucket soil layer.\n4 when it is the first bucket layer.\n\nThe third digit indicates whether the soil should avalanche below or above the bucket:\n\n0 when there is no bucket.\n1 when the soil should avalanche below the bucket.\n2 when the soil should avalanche on the top of the bucket.\n\nThe combination of these three digits provides a comprehensive description of how the soil should avalanche in different scenarios.\n\nNote\n\nThis function is intended for internal use only.\nNot all combinations for status are possible. Some combinations, such as 401, 231 and 220, are impossible.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nii_c::Int64: Index of the neighboring cell in the X direction.\njj_c::Int64: Index of the neighboring cell in the Y direction.\nh_min::Float64: Minimum allowed height for a stable configuration. [m]\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nstatus::Int64: Three-digit number indicating how the soil should avalanche.                  0 is returned if the soil column is stable.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nstatus = _check_unstable_terrain_cell(out, 10, 15, -0.1)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._locate_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}, Tuple{SimOut{B, I, T}, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._locate_unstable_terrain_cell","text":"_locate_unstable_terrain_cell(\n    out::SimOut{B,I,T}, dh_max::T, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function locates all the cells in terrain that have a height difference larger than dh_max with at least one neighboring cell. Such height difference may indicate that the soil column is unstable. However, it is important to note that this condition is not necessarily indicative of an actual soil instability, as a bucket or the soil resting on it could be supporting the soil column.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ndh_max::Float64: Maximum height difference allowed between two neighboring cells. [m]\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nunstable_cells::Vector{Vector{Int64}}: Collection of cells indices that are possibly                                          unstable.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nunstable_cells = _locate_unstable_terrain_cell(out, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._relax_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._relax_body_soil!","text":"_relax_body_soil!(\n    out::SimOut{B,I,T}, grid::GridParam{I,T}, sim::SimParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil in body_soil towards a state closer to equilibrium. The soil stability is determined by the repose_angle. If the slope formed by two neighboring soil columns exceeds the repose_angle, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.\n\nBy convention, this function only checks the stability of the soil in the four adjacent cells:                      ↑                    ← O →                      ↓\n\nThe diagonal directions are not checked for simplicity and performance reasons.\n\nThis function only moves the soil when the following conditions are met:\n\n(1) The soil column in the neighboring cell is low enough. (2) There is space on the top of the neighboring soil column.\n\nNote\n\nThis function is intended for internal use only.\nThis function is a work in progress.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nsim::SimParam{Int64,Float64}: Struct that stores information related to the                                 simulation.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nsim = SimParam(0.85, 3, 4)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_relax_body_soil!(out, grid, sim)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._relax_terrain!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._relax_terrain!","text":"_relax_terrain!(\n    out::SimOut{B,I,T}, grid::GridParam{I,T}, sim::SimParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil in terrain towards a state closer to equilibrium. The soil stability is determined by the repose_angle. If the slope formed by two neighboring soil columns exceeds the repose_angle, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.\n\nBy convention, this function only checks the stability of the soil in the four adjacent cells:                      ↑                    ← O →                      ↓\n\nThe diagonal directions are not checked for simplicity and performance reasons.\n\nThis function only moves the soil when the following conditions are met:\n\n(1) The soil column in the neighboring cell is low enough. (2) Either:         (a) The bucket is not on the soil, meaning there is space between the terrain and             the bucket, or there is no bucket.         (b) The bucket is on the terrain, but the combination of the bucket and bucket             soil is not high enough to prevent soil avalanche.\n\nIn case (2a), the soil will avalanche on the terrain, while in case (2b), the soil will avalanche on the bucket.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nsim::SimParam{Int64,Float64}: Struct that stores information related to the                                 simulation.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nsim = SimParam(0.85, 3, 4)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_relax_terrain!(out, grid, sim)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._relax_unstable_body_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, Array{Vector{I}, 1}, T, I, I, I, I, I, GridParam{I, T}}, Tuple{SimOut{B, I, T}, I, Array{Vector{I}, 1}, T, I, I, I, I, I, GridParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._relax_unstable_body_cell!","text":"_relax_unstable_body_cell!(\n    out::SimOut{B,I,T}, status::I, new_body_soil_pos::Vector{Vector{I}}, dh_max::T,\n    ii::I, jj::I, ind::I, ii_c::I, jj_c::I, grid::GridParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil from the soil layer ind of body_soil at (ii, jj) to the soil column in (ii_c, jj_c). The precise movement depends on the status number as explained in the _check_unstable_body_cell function.\n\nThe soil is moved such that the slope formed by the two neighboring soil columns is equal to the repose_angle, provided that the bucket is not preventing this configuration.\n\nNote\n\nThis function is intended for internal use only.\nIt is assumed that the given status is accurate, so no extra checks are present.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nstatus::Int64: Three-digit number indicating how the soil should avalanche.\nnew_body_soil_pos::Vector{Vector{Int64}}: Queue to append new bodysoilpos.\ndh_max::Float64: Maximum height difference allowed between two neighboring cells. [m]\nii::Int64: Index of the considered cell in the X direction.\njj::Int64: Index of the considered cell in the Y direction.\nind::Int64: Index of the considered soil layer.\nii_c::Int64: Index of the neighboring cell in the X direction.\njj_c::Int64: Index of the neighboring cell in the Y direction.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\nnew_body_soil_pos = Vector{Vector{Int64}}()\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_relax_unstable_body_cell!(out, 40, new_body_soil_pos, 0.1, 10, 15, 1, 10, 14, grid)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._relax_unstable_terrain_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._relax_unstable_terrain_cell!","text":"_relax_unstable_terrain_cell!(\n    out::SimOut{B,I,T}, status::I, dh_max::T, ii::I, jj::I, ii_c::I, jj_c::I,\n    grid::GridParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil from the terrain at (ii, jj) to the soil column in (ii_c, jj_c). The precise movement depends on the status number as explained in the _check_unstable_terrain_cell function.\n\nThe soil is moved such that the slope formed by the two neighboring soil columns is equal to the repose_angle. When the bucket is preventing this configuration, the soil avalanche below the bucket to fill the space under it.\n\nNote\n\nThis function is intended for internal use only.\nIt is assumed that the given status is accurate, so no extra checks are present.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nstatus::Int64: Three-digit number indicating how the soil should avalanche.\ndh_max::Float64: Maximum height difference allowed between two neighboring cells. [m]\nii::Int64: Index of the considered cell in the X direction.\njj::Int64: Index of the considered cell in the Y direction.\nii_c::Int64: Index of the neighboring cell in the X direction.\njj_c::Int64: Index of the neighboring cell in the Y direction.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_relax_unstable_terrain_cell!(out, 131, 0.1, 10, 15, 10, 14, grid)\n\n\n\n\n\n","category":"method"},{"location":"utils/#Documentation-for-utils.jl","page":"utils.jl","title":"Documentation for utils.jl","text":"","category":"section"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"This file aggregates a collection of utility functions. Information for some of these functions are provided below.","category":"page"},{"location":"utils/#Checking-functions","page":"utils.jl","title":"Checking functions","text":"","category":"section"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"This corresponds to the functions check_volume and check_soil, which can be used to check the validity of the simulation outputs. It is important to call these functions either before or after the simulation stepping process, as the outputs may be temporarily invalid during the stepping.","category":"page"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"The check_volume function verifies mass conservation, ensuring that the total mass of soil is properly conserved throughout the simulation.  The check_soil function checks the coherence and integrity of the terrain, bucket soil, and bucket. It ensures that there are no intersections or conflicting cell assignments between these three groups.","category":"page"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"Note that these functions are computationally intensive and may slow down the simulation. Therefore, it is recommended to use them primarily for debugging and testing purposes.","category":"page"},{"location":"utils/#Writing-functions","page":"utils.jl","title":"Writing functions","text":"","category":"section"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"This corresponds to the functions write_soil and write_bucket, which can be used to write the outputs into csv files. The write_bucket function generates files starting with bucket, containing the Cartesian coordinates of the four bucket walls' edges. Conversely, the write_soil function generates files starting with terrain for the terrain height and body_soil for the bucket soil height. All the output files are saved in the results folder, with sequentially increasing numbers appended to the filenames.","category":"page"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"Note that these functions are primarily designed to be used in the example script provided. Consequently, they have potential limitations that should be considered by the user. Firstly, the file numbers are assigned sequentially. If the write_bucket and write_soil functions are not called together consistently, the file numbers of the bucket and terrain may not correspond. Additionally, this may cause issues if existing files are present in the results folder.","category":"page"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"Secondly, the file formats generated by these functions are specifically designed for visualization with Paraview. To visualize the data using a different tool, some change to the file formats may be needed.","category":"page"},{"location":"utils/#_locate_all_non_zeros","page":"utils.jl","title":"_locate_all_non_zeros","text":"","category":"section"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"The purpose of this function is to provide a list of indices corresponding to the non-zero elements of either the body or body_soil field of the SimOut struct. body and body_soil are a vector of Sparse Matrices indicating the location of the bucket and bucket soil, respectively. Sparse Matrices are used to speed up the code and reduce memory allocation, but this function is still slow and should be used only when necessary.","category":"page"},{"location":"utils/#API","page":"utils.jl","title":"API","text":"","category":"section"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"Modules = [SoilDynamics]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"utils/#SoilDynamics._init_sparse_array!-Union{Tuple{T}, Tuple{I}, Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}, GridParam{I, T}}} where {I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics._init_sparse_array!","text":"_init_sparse_array!(\n    sparse_array::Vector{SparseMatrixCSC{T,I}}, grid::GridParam{I,T}\n) where {I<:Int64,T<:Float64}\n\nThis function reinitializes sparse_array. sparse_array is expected to be either body or body_soil.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nsparse_array::Vector{SparseMatrixCSC{Float64,Int64}}: Either body or body_soil.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_init_sparse_array!(out.body, grid)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics._locate_all_non_zeros-Union{Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}}, Tuple{T}, Tuple{I}} where {I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics._locate_all_non_zeros","text":"_locate_all_non_zeros(\n    sparse_array::Vector{SparseMatrixCSC{T,I}}\n) where {I<:Int64,T<:Float64}\n\nThis function returns the indices of all non-zero values in sparse_array. sparse_array is expected to be either body or body_soil.\n\nNote\n\nThis function is intended for internal use only.\nThe first index in the returned vector corresponds to the bucket layer, while the second and third indices are the indices in the X and Y direction, respectively.\n\nInputs\n\nsparse_array::Vector{SparseMatrixCSC{Float64,Int64}}: Either body or body_soil.\n\nOutputs\n\nVector{Vector{Int64}}:: Collection of cells indices where sparse_array is non-zero.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nbody_soil_pos = _locate_all_non_zeros(out.body_soil)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics._locate_non_zeros-Union{Tuple{SparseArrays.SparseMatrixCSC{T, I}}, Tuple{T}, Tuple{I}} where {I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics._locate_non_zeros","text":"_locate_non_zeros(\n    sparse_matrix::SparseMatrixCSC{T,I}\n) where {I<:Int64,T<:Float64}\n\nThis function returns the indices of all non-zero values in a sparse Matrix.\n\nNote\n\nThis function is intended for internal use only.\nThis implementation is faster than a simple loop.\n\nInputs\n\nsparse_matrix::SparseMatrixCSC{Float64,Int64}: Input Matrix for which non-zero values                                                  should be located.\n\nOutputs\n\nVector{Vector{Int64}}:: Collection of cells indices where the value of the input Matrix                           is non-zero.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nnon_zeros = _locate_non_zeros(out.body[1])\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics._write_vector-Union{Tuple{T}, Tuple{Any, T, T, T}} where T<:Float64","page":"utils.jl","title":"SoilDynamics._write_vector","text":"_write_vector(\n    io, x::T, y::T, z::T\n) where {T<:Float64}\n\nThis is an utility function to write a 3D vector, such as Cartesian coordinates, into a file.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nio: Used as a reference to the writing file.\nx::Float64: X coordinate of the position to write.\ny::Float64: Y coordinate of the position to write.\nz::Float64: Z coordinate of the position to write.\n\nOutputs\n\nNone\n\nExample\n\nopen(\"file.txt\", \"a\") do io\n    write_vector(io, 0.0, 0.0, 1.0)\nend\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.calc_normal-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T<:Float64","page":"utils.jl","title":"SoilDynamics.calc_normal","text":"calc_normal(\n    a::Vector{T}, b::Vector{T}, c::Vector{T}\n) where {T<:Float64}\n\nThis function calculates the unit normal vector of a plane formed by three points using the right-hand rule.\n\nNote\n\nThe input order of the points is important as it determines the sign of the unit normal vector based on the right-hand rule.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of the first point of the plane. [m]\nb::Vector{Float64}: Cartesian coordinates of the second point of the plane. [m]\nc::Vector{Float64}: Cartesian coordinates of the third point of the plane. [m]\n\nOutputs\n\nVector{T}: Unit normal vector of the provided plane. [m]\n\nExample\n\na = [0.0, 0.0, 0.0]\nb = [1.0, 0.5, 0.23]\nc = [0.1, 0.2, -0.5]\n\nunit_normal = calc_normal(a, b, c)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.check_soil-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics.check_soil","text":"check_soil(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function checks that all the simulation outputs follow the conventions of the simulator. If any inconsistency is found, a warning is issued. The conventions that are checked include:\n\nThe terrain should not overlap with the bucket.\nThe bucket should be properly defined, with its maximum height higher than its minimum height.\nThe bucket soil should be properly defined, with its maximum height higher than its minimum height.\nThe two bucket layers should not overlap or touch each other.\nOne bucket layer should not overlap with all bucket soil layer.\nThe bucket should not overlap with the corresponding bucket soil layer.\nThe bucket soil layer should be resting on the corresponding bucket layer.\nThe bucket should be present when there is bucket soil.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\ncheck_soil(out)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.check_volume-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T, GridParam{I, T}}} where {B<:Bool, I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics.check_volume","text":"check_volume(\n    out::SimOut{B,I,T}, init_volume::T, grid::GridParam{I,T}\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function checks that the volume of soil is conserved. The initial volume of soil (init_volume) has to be provided.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ninit_volume::Float64: Initial volume of soil in the terrain. [m^3]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\ninit_volume = 0.0\n\ncheck_volume(out, init_volume, grid)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.set_RNG_seed!-Union{Tuple{}, Tuple{I}} where I<:Int64","page":"utils.jl","title":"SoilDynamics.set_RNG_seed!","text":"set_RNG_seed!(\n    seed::I=1234\n) where {I<:Int64}\n\nThis function sets the used RNG seed.\n\nInputs\n\nseed::Int64: Value of the RNG seed.\n\nOutputs\n\nNone\n\nExample\n\nset_RNG_seed!(1234)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.write_bucket-Union{Tuple{BucketParam{T}}, Tuple{T}} where T<:Float64","page":"utils.jl","title":"SoilDynamics.write_bucket","text":"write_bucket(\n    bucket::BucketParam{T}\n) where {T<:Float64}\n\nThis function writes the position of all bucket faces into a csv located in the \"results\" directory. The file is named \"bucket\" followed by the file number.\n\nInputs\n\nbucket::BucketParam{Float64}: Struct that stores information related to the                                 bucket object.\n\nOutputs\n\nNone\n\nExample\n\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\nbucket = BucketParam(o, j, b, t, 0.5)\n\nwrite_bucket(bucket)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.write_soil-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}}} where {B<:Bool, I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics.write_soil","text":"write_soil(\n    out::SimOut{B,I,T}, grid::GridParam{I,T}\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function writes the terrain and the bucket soil into a csv located in the \"results\" directory. terrain and body_soil are saved into files named \"terrain\" and \"body_soil\", respectively, followed by the file number.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid\n\nwrite_soil(out, grid)\n\n\n\n\n\n","category":"method"},{"location":"grid/#Documentation-for-the-simulation-grid","page":"Grid","title":"Documentation for the simulation grid","text":"","category":"section"},{"location":"grid/","page":"Grid","title":"Grid","text":"The simulation takes place on a rectangular 3D grid made of rectangular prism cells. An illustration of the 3D grid is given below along with the representation of a grid element.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"(Image: Simulation grid)","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"The grid is created by the GridParam struct by providing the maximum size in the XYZ directions (grid_size_x, grid_size_y, and grid_size_z, respectively) and the size of a grid element (cell_size_xy and cell_size_z).","category":"page"},{"location":"grid/#Grid-elements","page":"Grid","title":"Grid elements","text":"","category":"section"},{"location":"grid/","page":"Grid","title":"Grid","text":"The grid elements have equal size in the X and Y direction (cell_size_xy), while their height (cell_size_z) should be lower or equal than their lateral extent. By convention, the origin of each cell is assumed to be in the center of their top surface (red point in the illustration). This is particularly important when associating 3D positions to cell indices.","category":"page"},{"location":"grid/#Grid-geometry","page":"Grid","title":"Grid geometry","text":"","category":"section"},{"location":"grid/","page":"Grid","title":"Grid","text":"The extent of the grid in meter is:","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"[-grid_size_x, grid_size_x] in the X direction, corresponding to 2 * half_length_x + 1 grid elements.\n[-grid_size_y, grid_size_y] in the Y direction, corresponding to 2 * half_length_y + 1 grid elements.\n[-grid_size_z, grid_size_z] in the Z direction, corresponding to 2 * half_length_z + 1 grid elements.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"The grid is therefore centered in 0. Note that the the right-hand rule is used so that the Z direction is pointing upward.","category":"page"},{"location":"bucket/#Documentation-for-bucket.jl","page":"bucket.jl","title":"Documentation for bucket.jl","text":"","category":"section"},{"location":"bucket/#General-description-of-the-simulated-excavator-bucket","page":"bucket.jl","title":"General description of the simulated excavator bucket","text":"","category":"section"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"The excavator's bucket has usually a complex shape that is not suitable for first-order modelling. In this simulator, the bucket is approximated as a triangular prism to simplify its representation. An illustration of the simulated bucket is provided below.","category":"page"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"(Image: Approximated bucket)","category":"page"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"The different parts of the bucket are labeled as follows:","category":"page"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"J represents the bucket joint.\nB represents the bucket base.\nT represents the bucket teeth.\nThe surface defined by the vertices T_lT_rB_rB_l is referred to as the bucket base.\nThe surface defined by the vertices J_lJ_rB_rB_l is referred to as the bucket back.\nThe surface defined by the vertices J_rB_rT_r is referred to as the bucket right side.\nThe surface defined by the vertices J_lB_lT_l is referred to as the bucket left side.\nThe surface defined by the vertices J_lJ_rT_rT_l is referred to as the bucket front. Note that it does not correspond to a bucket wall.","category":"page"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"The reference pose of the bucket is specified when creating the BucketParam struct and is defined by the fields j_pos_init, b_pos_init, and t_pos_init, which correspond to the positions of the bucket joint, base, and teeth, respectively. The center of rotation for the bucket is typically the bucket joint, but it can be a different point depending on the specific bucket design. In that case, a different bucket origin can be provided when building BucketParam. The position of the bucket joint, base, and teeth are generally defined relative to the bucket origin.","category":"page"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"The pose of the bucket is provided to the simulator as the Cartesian position of the bucket origin and its orientation relative to the reference pose, using the Quaternion notation.","category":"page"},{"location":"bucket/#Determination-of-the-bucket-position","page":"bucket.jl","title":"Determination of the bucket position","text":"","category":"section"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"The purpose of the functions in this file is to determine the position of the excavator bucket within the 3D grid. Specifically, it aims to identify, for each XY position in the grid, the minimum and maximum height of the bucket if it is present at that location. The algorithm used for this task has been optimized for performance, resulting in an efficient implementation. However, due to the optimization, the algorithm may appear complex or unintuitive.","category":"page"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"The basic idea under the implementation is to decompose the bucket into its 4 surfaces (base, back, left side, right side), and to identify for each XY position of the grid the minimum and maximum height of the given bucket wall. The results for the four surfaces are then aggregated, sorted and duplicates are removed. It is then straightforward to determine for each XY position the minimum and maximum height of the bucket using this information. Although a different implementation is present for the rectangular surfaces (base and back) and for the triangular surfaces (left and right side), the algorithm is almost identical.","category":"page"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"The position of the bucket wall is determined using a three-steps process:","category":"page"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"(1) Each XY position within the bounding box of the bucket wall is decomposed into the reference vectors of the considered surface. This allows to easily determine whether a given XY position falls inside or outside the projection of the bucket wall into the horizontal plane.\n(2) For each XY position (ii, jj) within the projection of the bucket wall into the horizontal plane, the height of the bucket wall at the cell corner (ii + 0.5, jj + 0.5) is calculated and added to the tally. By iterating over all the cells, the algorithm ensures that the height of the bucket is calculated at the 4 corners of each cell within the projection of the bucket wall into the horizontal plane. This is crucial because the minimum and maximum height of a plane intersecting laterally a cell is occurring necessarily at one of the cell's corner.\n(3) An issue of this algorithm is that it does not handle the case where the bucket wall is either not fully intersecting the cell or intersecting vertically the cell. Those cases are handled separately by identifying all the cells where the edges of the bucket wall are located. This is simply done by decomposing each edges into a certain number of equally spaced points, and then determining where each points is located.","category":"page"},{"location":"bucket/#API","page":"bucket.jl","title":"API","text":"","category":"section"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"Modules = [SoilDynamics]\nPages   = [\"bucket.jl\"]","category":"page"},{"location":"bucket/#SoilDynamics._calc_bucket_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_bucket_pos!","text":"_calc_bucket_pos!(\n    out::SimOut{B,I,T}, pos::Vector{T}, ori::Quaternion{T}, grid::GridParam{I,T},\n    bucket::BucketParam{I,T}, sim::SimParam{I,T}, step_bucket_grid::T=0.5, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function determines all the cells where the bucket is located. The bucket position is calculated based on its reference pose stored in the bucket struct, as well as the provided position (pos) and orientation (ori). pos and ori are used to apply the appropriate translation and rotation to the bucket relative to its reference pose. The center of rotation is assumed to be the bucket origin. The orientation is provided using the quaternion definition.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\npos::Vector{Float64}: Cartesian coordinates of the bucket origin. [m]\nori::Quaternion{Float64}: Orientation of the bucket. [Quaternion]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nbucket::BucketParam{Float64}: Struct that stores information related to the                                 bucket object.\nsim::SimParam{Int64,Float64}: Struct that stores information related to the                                 simulation.\nstep_bucket_grid::Float64: Spatial increment used to decompose the edges of the bucket.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\npos = [0.5, 0.3, 0.4]\nori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\nbucket = BucketParam(o, j, b, t, 0.5)\nsim = SimParam(0.85, 3, 4)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_calc_bucket_pos!(out, pos, ori, grid, bucket, sim)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_line_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, T, GridParam{I, T}}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_line_pos","text":"_calc_line_pos(\n    a::Vector{T}, b::Vector{T}, delta::T, grid::GridParam{I,T}\n) where {I<:Int64,T<:Float64}\n\nThis function determines all the cells that lie on a straight line between two Cartesian coordinates.\n\nFor the sake of accuracy, the line is divided into smaller segments using a spatial increment delta.\n\nThe coordinates of each sub-point (ab_i) along the line can then be calculated as\n\nab_i = a + ab * i * delta / norm(ab)\n\nwhere i is the increment number and ab = b - a. The Cartesian coordinates can then be converted into indices\n\nab_i_ind = ab_i / cell_size + grid_half_length + 1\n\nFinally, the floating-point values are rounded to obtain the cell indices in the X, Y, Z directions. As the center of each cell is considered to be on the center of the top surface, round should be used for getting the cell indices in the X and Y direction, while ceil should be used for the Z direction.\n\nNote\n\nThis function is intended for internal use only.\nWhen the line follows a cell border, the exact location of the line becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of the first extremity of the line. [m]\nb::Vector{Float64}: Cartesian coordinates of the second extremity of the line. [m]\ndelta::Float64: Spatial increment used to decompose the line. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nline_pos::Vector{Vector{Int64}}: Collection of cells indices where the line is located.                                    Result is not sorted and duplicates should be expected.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.5, 0.7]\nb = [0.7, 0.8, -0.3]\n\nline_pos = _calc_line_pos(a, b, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_rectangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_rectangle_pos","text":"_calc_rectangle_pos(\n    a::Vector{T}, b::Vector{T}, c::Vector{T}, d::Vector{T},\n    delta::T, grid::GridParam{I,T}, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function determines the cells where a rectangle surface is located. The rectangle is defined by providing the Cartesian coordinates of its four vertices in the proper order.\n\nTo optimize performance, the function iterates over a portion of the horizontal grid where the rectangle is located. For each cell, the function calculates the height of the plane formed by the rectangle at the top right corner of the cell. If the cell is within the rectangle area, the calculated height is added to the results for the four neighboring cells.\n\nThis method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.\n\nHowever, this approach does not work when the rectangle is perpendicular to the XY plane. To handle this case, the function uses the _calc_line_pos function to include the cells that lie on the four edges of the rectangle.\n\nNote\n\nThis function is intended for internal use only.\nThe iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.\nNot all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.\nWhen the rectangle follows a cell border, the exact location of the rectangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nb::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nc::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nd::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\ndelta::Float64: Spatial increment used to decompose the edges of the rectangle. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices where the rectangle is located.                          Result is not sorted and duplicates may be present.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.0, 0.7]\nb = [0.0, 1.0, 0.7]\nc = [0.0, 1.0, 0.9]\nd = [1.0, 0.0, 0.9]\n\nrect_pos = _calc_rectangle_pos(a, b, c, d, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_triangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_triangle_pos","text":"_calc_triangle_pos(\n    a::Vector{T}, b::Vector{T}, c::Vector{T},\n    delta::T, grid::GridParam{I,T}, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function determines the cells where a triangle surface is located. The triangle is defined by providing the Cartesian coordinates of its three vertices in the proper order.\n\nTo optimize performance, the function iterates over a portion of the horizontal grid where the triangle is located. For each cell, the function calculates the height of the plane formed by the triangle at the top right corner of the cell. If the cell is within the triangle area, the calculated height is added to the results for the four neighboring cells.\n\nThis method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.\n\nHowever, this approach does not work when the triangle is perpendicular to the XY plane. To handle this case, the function uses the _calc_line_pos function to include the cells that lie on the three edges of the triangle.\n\nNote\n\nThis function is intended for internal use only.\nThe iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.\nNot all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.\nWhen the triangle follows a cell border, the exact location of the triangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\nb::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\nc::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\ndelta::Float64: Spatial increment used to decompose the edges of the triangle. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices where the triangle is located.                          Result is not sorted and duplicates may be present.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.0, 0.7]\nb = [0.0, 1.0, 0.7]\nc = [0.0, 1.0, 0.9]\n\ntri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._decompose_vector_rectangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._decompose_vector_rectangle","text":"_decompose_vector_rectangle(\n    ab_ind::Vector{T}, ad_ind::Vector{T}, a_ind::Vector{T},\n    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function performs a vector decomposition on a portion of the horizontal plane where a rectangle ABCD is located. The position of the rectangle is defined by its edges AB and AD, while the specified area extends over [area_min_x, area_min_x + area_length_x] on the X direction and [area_min_y, area_min_y + area_length_y] on the Y direction.\n\nFor each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AD. Let O be the name of a cell, it can then be decomposed as\n\nAO = c_ab * AB + c_ad * AD.\n\nThis decomposition leads to a system of 2 equations with 2 unknowns (cab and cad)\n\nAO[1] = c_ab * AB[1] + c_ad * AD[1] {1},\nAO[2] = c_ab * AB[2] + c_ad * AD[2] {2}.\n\nOne may note that AB[1] * {2} - AB[2] * {1} implies that\n\nAB[1] * AO[2] - AB[2] * AO[1] = c_ad * AD[2] * AB[1] - c_ad * AD[1] * AB[2]\n\nthat can be further rewritten as\n\nc_ad = (AB[1] * AO[2] - AB[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).\n\nSimilarly, AD[1] * {2} - AD[2] * {1} implies that\n\nc_ab = -(AD[1] * AO[2] - AD[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).\n\nThis decomposition allows us to determine whether the cell O is inside the rectangle area, since this requires cab and cad to be between 0 and 1.\n\nNote\n\nThis function is intended for internal use only.\nBy convention, the decomposition is done at the top right corner of each cell.\n\nInputs\n\nab_ind::Vector{Float64}: Indices representing the edge AB of the rectangle.\nad_ind::Vector{Float64}: Indices representing the edge AD of the rectangle.\na_ind::Vector{Float64}: Indices of the vertex A from which the edges AB and AD start.\narea_min_x::Int64: Minimum index in the X direction of the specified area.\narea_min_y::Int64: Minimum index in the Y direction of the specified area.\narea_length_x::Int64: Number of grid elements in the X direction of the specified area.\narea_length_y::Int64: Number of grid elements in the Y direction of the specified area.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nc_ab::Matrix{Float64}: Results of the vector decomposition in terms of the AB component.\nc_ad::Matrix{Float64}: Results of the vector decomposition in terms of the AD component.\nin_rectangle::Matrix{Bool}: Indicates whether the cell is inside the rectangle area.\nn_cell::Int64: Number of cells inside the rectangle area.\n\nExample\n\nab_ind = [0, 4, 0]\nad_ind = [3, 0, 0]\na_ind = [10, 8, 25]\n\nc_ab, c_ad, in_rectangle, n_cell = _decompose_vector_rectangle(\n    ab_ind, ad_ind, a_ind, 15, 12, 8, 7\n)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._decompose_vector_triangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._decompose_vector_triangle","text":"_decompose_vector_triangle(\n    ab_ind::Vector{T}, ac_ind::Vector{T}, a_ind::Vector{T},\n    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function performs a vector decomposition on a portion of the horizontal plane where a triangle ABC is located. The position of the triangle is defined by its edges AB and AC , while the specified area extends over [area_min_x, area_min_x + area_length_x] on the X direction and [area_min_y, area_min_y + area_length_y] on the Y direction.\n\nFor each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AC. Let O be the name of a cell, it can then be decomposed as\n\nAO = c_ab * AB + c_ac * AC.\n\nThis decomposition leads to a system of 2 equations with 2 unknowns (cab and cac)\n\nAO[1] = c_ab * AB[1] + c_ac * AC[1] {1},\nAO[2] = c_ab * AB[2] + c_ac * AC[2] {2}.\n\nOne may note that AB[1] * {2} - AB[2] * {1} implies that\n\nAB[1] * AO[2] - AB[2] * AO[1] = c_ac * AC[2] * AB[1] - c_ac * AC[1] * AB[2]\n\nthat can be further rewritten as\n\nc_ac = (AB[1] * AO[2] - AB[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).\n\nSimilarly, AC[1] * {2} - AC[2] * {1} implies that\n\nc_ab = -(AC[1] * AO[2] - AC[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).\n\nThis decomposition allows us to determine whether the cell O is inside the triangle area, since this requires cab and cac to be between 0 and 1, and the sum of cab and cac to be lower than 1.\n\nNote\n\nThis function is intended for internal use only.\nBy convention, the decomposition is done at the top right corner of each cell.\n\nInputs\n\nab_ind::Vector{Float64}: Indices representing the edge AB of the triangle.\nac_ind::Vector{Float64}: Indices representing the edge AC of the triangle.\na_ind::Vector{Float64}: Indices of the vertex A from which the edges AB and AC start.\narea_min_x::Int64: Minimum index in the X direction of the specified area.\narea_min_y::Int64: Minimum index in the Y direction of the specified area.\narea_length_x::Int64: Number of grid elements in the X direction of the specified area.\narea_length_y::Int64: Number of grid elements in the Y direction of the specified area.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nc_ab::Matrix{Float64}: Results of the vector decomposition in terms of the AB component.\nc_ac::Matrix{Float64}: Results of the vector decomposition in terms of the AC component.\nin_triangle::Matrix{Bool}: Indicates whether the cell is inside the triangle area.\nn_cell::Int64: Number of cells inside the triangle area.\n\nExample\n\nab_ind = [0, 4, 0]\nac_ind = [3, 0, 0]\na_ind = [10, 8, 25]\n\nc_ab, c_ac, in_triangle, n_cell = _decompose_vector_triangle(\n    ab_ind, ac_ind, a_ind, 15, 12, 8, 7\n)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._include_new_body_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T, T}, Tuple{SimOut{B, I, T}, I, I, T, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._include_new_body_pos!","text":"_include_new_body_pos!(\n    out::SimOut{B,I,T}, ii::I, jj::I, min_h::T, max_h::T, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function updates the bucket position in body at the coordinates (ii, jj). The minimum and maximum heights of the bucket at that position are given by min_h and max_h, respectively. If the given position overlaps with an existing position, then the existing position is updated as the union of the two positions. Otherwise, a new position is added to body.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nii::Int64: Index of the considered position in the X direction.\njj::Int64: Index of the considered position in the Y direction.\nmin_h::Float64: Minimum height of the bucket. [m]\nmax_h::Float64: Maximum height of the bucket. [m]\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_include_new_body_pos!(out, 10, 15, 0.5, 0.6)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._update_body!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._update_body!","text":"_update_body!(\n    area_pos::Vector{Vector{I}}, out::SimOut{B,I,T}, grid::GridParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function updates the bucket position in body following the cells composing area_pos. For each XY position, the first cell found in area_pos corresponds to the minimum height of the bucket, while the last one provides the maximum height. As a result, this function must be called separately for each bucket wall.\n\nNote\n\nThis function is intended for internal use only.\narea_pos must be sorted and not be empty.\n\nInputs\n\narea_pos::Vector{Vector{Int64}}: A collection of cell indices specifying where a bucket                                    wall is located.\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\na = [1.0, 0.0, 0.7]\nb = [0.0, 1.0, 0.7]\nc = [0.0, 1.0, 0.9]\ntri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)\n\n_update_body!(tri_pos, out, grid)\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This soil dynamics simulator is a fast first-order model designed to simulate soil displacement caused by the movement of an excavator bucket. While excavator buckets have complex shapes to efficiently dig soil, here, for the sake of performance, the bucket is approximated as a simple triangular prism, which is a good representation for its overall shape. A detailed description of the model used for the bucket is available on the bucket page of this documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this simulator, the movement of soil is modelled using a cellular automata approach on a regular 3D grid. The simulation grid is composed of rectangular cells with equal length in the X and Y directions, and a height that is less than or equal to the cell's length (more details is available on the Grid page of this documentation). The fundamental idea of cellular automata is to decompose a simulation grid into cells that can have different states. In this case, the state corresponds to soil, bucket or empty. These cells can be moved at every step of the simulation depending on a set of rules.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the start of each step, the bucket cells are assigned following the location of the bucket, and only soil cells are allowed to move. There are two types of movement for soil cells: movement of intersecting soil cells and soil relaxation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Intersecting cells refer to cells where both soil and bucket are present due to the bucket movement. The soil in these intersecting cells have to be moved in response to the bucket movement. The movement of intersecting soil cells follows a complex set of rules that is described in the intersecting_cells page of this documentation.\nSoil relaxation refers to the natural movement of soil. Here, it is assumed that soil with a slope greater than the repose angle is unstable and should avalanche to reach a configuration where the slope is equal to the repose angle. However, implementing this simple model becomes challenging due to the interaction between soil and the bucket. The set of rules applied for soil relaxation is described in the relax page of this documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please note that the terrain must be updated every time the bucket moves by more than one cell. This ensures that the simulator keeps track of how the soil should be moved accurately.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to the core functionalities, the structs used in this simulator are described in the types page of this documentation. These structs provide a safe way of passing input arguments to the simulator's public functions, simplifying and accelerating the implementation. Utilities functions are described in the utils page of this documentation. In particular, the functions used to check the outputs of the simulator or to write the outputs into csv files are described.","category":"page"},{"location":"types/#Documentation-for-types.jl","page":"types.jl","title":"Documentation for types.jl","text":"","category":"section"},{"location":"types/#Introductory-remarks","page":"types.jl","title":"Introductory remarks","text":"","category":"section"},{"location":"types/","page":"types.jl","title":"types.jl","text":"The simulator relies on structs to organize and manage the various parameters and properties. These structs are designed to provide a clear and efficient way of passing input arguments to the simulator's public functions.","category":"page"},{"location":"types/","page":"types.jl","title":"types.jl","text":"To ensure the integrity and validity of the input parameters, the structs are constructed using inner constructors that perform appropriate checks. This guarantees that the simulator operates under the assumption of correct and consistent input data. If incorrect parameters are provided, the user will be alerted through appropriate warnings or error messages.","category":"page"},{"location":"types/","page":"types.jl","title":"types.jl","text":"In Julia, the default behavior for float, bool, and int fields in structs is immutability. While immutability is desirable in some cases, it may not always align with the intended behavior of the simulator. To address this, the approach taken here is to use Vectors containing a single element when mutability is required. By using Vectors, Matrices, or Arrays, the mutability of the corresponding fields in the structs can be ensured.","category":"page"},{"location":"types/","page":"types.jl","title":"types.jl","text":"The current implementation includes four distinct types of structs:","category":"page"},{"location":"types/","page":"types.jl","title":"types.jl","text":"GridParam: Aggregates all the properties related to the simulation grid.\nBucketParam: Aggregates all the properties associated with the bucket.\nSimParam: Aggregates the general parameters and settings for the simulation.\nSimOut: Aggregates and manages the output data generated during the simulation.","category":"page"},{"location":"types/","page":"types.jl","title":"types.jl","text":"These structs play a crucial role in organizing and encapsulating the various aspects of the simulator, providing a convenient and structured way to work with the simulation inputs and outputs.","category":"page"},{"location":"types/#API","page":"types.jl","title":"API","text":"","category":"section"},{"location":"types/","page":"types.jl","title":"types.jl","text":"Modules = [SoilDynamics]\nPages   = [\"types.jl\"]","category":"page"},{"location":"types/#SoilDynamics.BucketParam","page":"types.jl","title":"SoilDynamics.BucketParam","text":"BucketParam{T<:Float64}\n\nStore all parameters related to a bucket object.\n\nConvention\n\nThe bucket is approximated as a triangular prism\n               A ____________________ D\n              /.                     /|\n             / .                    / |\n            /  .                   /  |\n           /   .                  /   |\n          /    .                 /    |\n         /     .                /     |\n        /      .               /      |\n       /       C . . . . . .  / . . . F\n      /      .               /        ̸\n     /     .                /       ̸\n    /    .                 /      ̸\n   /   .                  /     ̸\n  /  .                   /    ̸\n / .                    /   ̸\nB ____________________ E\nThe middle of the segment AD is referred to as the bucket \"joint\".\nThe middle of the segment CF is referred to as the bucket \"base\".\nThe middle of the segment BE is referred to as the bucket \"teeth\".\nThe surface ABED is open and referred to as the bucket \"front\".\nThe surface BCFE is a bucket wall and referred to as the bucket \"base\".\nThe surface ACFD is a bucket wall and referred to as the bucket \"back\".\nThe surface ABC is a bucket wall and referred to as the bucket \"right side\".\nThe surface DEF is a bucket wall and referred to as the bucket \"left side\".\nThe bucket has a constant width, denoted as\nAD = BE = CF = width.\nThe center of rotation of the bucket is assumed to be at the bucket \"origin\" (not shown in the figure) and the bucket vertices are given relative to this origin.\nThe provided coordinates are assumed to be the reference pose of the bucket, from which the bucket pose is calculated throughout the code.\n\nFields\n\nj_pos_init::Vector{Float64}: Cartesian coordinates of the bucket joint in its                                reference pose. [m]\nb_pos_init::Vector{Float64}: Cartesian coordinates of the bucket base in its                                reference pose. [m]\nt_pos_init::Vector{Float64}: Cartesian coordinates of the bucket teeth in its                                reference pose. [m]\nwidth::Float64: Width of the bucket. [m]\npos::Vector{Float64}: Cartesian coordinates of the bucket origin. [m]\nori::Vector{Float64}: Orientation of the bucket. Note that it is stored as a Vector,                         since Quaternions are not mutable. [Quaternion]\n\nInner constructor\n\nBucketParam(\n    o_pos_init::Vector{T}, j_pos_init::Vector{T}, b_pos_init::Vector{T},\n    t_pos_init::Vector{T}, width::T\n) where {T<:Float64}\n\nCreate a new instance of BucketParam using the reference positions of the bucket origin, joint, base, and teeth as well as the bucket width. The position of the bucket joint, base, and teeth are given relative to the position of the bucket origin.\n\nRequirements:\n\nAll provided Cartesian coordinates should be a vector of size 3.\nThe bucket joint, base and teeth should have strictly different location.\nThe bucket width should be greater than zero.\n\nExample\n\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\n\nbucket = BucketParam(o, j, b, t, 0.5)\n\nThis would create a bucket ABCDEF with its center of rotation at the bucket joint and with A = [0.0, -0.25, 0.0], B = [1.0, -0.25, -0.5], C = [0.0, -0.25, -0.5] D = [0.0, 0.25, 0.0], E = [1.0, 0.25, -0.5], F = [0.0, 0.25, -0.5].\n\n\n\n\n\n","category":"type"},{"location":"types/#SoilDynamics.GridParam","page":"types.jl","title":"SoilDynamics.GridParam","text":"GridParam{I<:Int64,T<:Float64}\n\nStore all parameters related to the simulation grid.\n\nConvention\n\nThe simulation grid is centred at 0, that is, if the extent of the grid is 10.0, the grid would then extend from -5.0 to 5.0, this applies to all direction.\nThe grid is composed of regular 3D cells\n          H-----------G\n         /           /|\n        /     O     / |\n       /           /  |\n      E-----------F   C\n      |           |  /\n      |           | /\n      |           |/\n      A-----------B\nThe cells have the same size in both lateral direction\nAB = BC = CD = DA = EF = FG = GH = HE,\nwhile their height can potentially be lower\nAE = BF = CG = DH <= AB.\nThe center of each cell (O) is considered to be at the center of the top surface.\nThe considered reference frame follows the right-hand rule, with the Z direction pointing upward.\n\nFields\n\nhalf_length_x::Int64: Number of grid elements in the positive (or negative) X direction.\nhalf_length_y::Int64: Number of grid elements in the positive (or negative) Y direction.\nhalf_length_z::Float64: Number of grid elements in the positive (or negative) Z                           direction. Note that it is a Float.\ncell_size_xy::Float64: Size of the cells in the X and Y direction. [m]\ncell_size_z::Float64: Height of the cells in the Z direction. [m]\ncell_area::Float64: Surface area of one cell in the horizontal plane. [m^2]\ncell_volume::Float64: Volume of one cell. [m^3]\nvect_x::StepRangeLen{Float64}: Vector providing a conversion between cell's index and                                  cell's position in the X direction.\nvect_y::StepRangeLen{Float64}: Vector providing a conversion between cell's index and                                  cell's position in the Y direction.\nvect_z::StepRangeLen{Float64}: Vector providing a conversion between cell's index and                                  cell's position in the Z direction.\n\nInner constructor\n\nGridParam(\n    grid_size_x::T, grid_size_y::T, grid_size_z::T, cell_size_xy::T,\n    cell_size_z::T=cell_size_xy\n) where {T<:Float64}\n\nCreate a new instance of GridParam using the grid size in [m]. The actual size of the grid would be:\n\n[-gridsizex, gridsizex] in the X direction.\n[-gridsizey, gridsizey] in the Y direction.\n[-gridsizez, gridsizez] in the Z direction.\n\nRequirements:\n\nAll inputs should be greater than zero.\ncellsizexy should be lower than or equal to gridsizex and gridsizey.\ncellsizez should be lower than or equal to gridsizez.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\n\nThis would create a grid of size [-4, 4] in the X direction, [-4, 4] in the Y direction, [-3, 3] in the Z direction, and with cells of size 0.05 x 0.05 x 0.01 in the XYZ direction.\n\n\n\n\n\n","category":"type"},{"location":"types/#SoilDynamics.SimOut","page":"types.jl","title":"SoilDynamics.SimOut","text":"SimOut{B<:Bool,I<:Int64,T<:Float64}\n\nStore all outputs of the simulation.\n\nConvention\n\nThe terrain Matrix stores the height of the terrain at each XY position, see the GridParam struct for more information on the simulation grid.\nThe cells where a bucket wall is located is stored in body, which is a vector of sparse Matrices. At each XY position, the first sparse Matrix indicates the lowest height where a bucket wall is located while the second sparse Matrix indicates the maximum height of this bucket wall. If a second bucket wall is located at the same XY position, its minimum and maximum height are indicated in the third and fourth sparse Matrix, respectively.\nFor each bucket, there can be only two distinct bucket walls located at the same XY position. As a result, the number of sparse Matrices in the body vector should be equal to four times the number of bucket.\nSimilarly, body_soil stores the location of the soil resting on a bucket wall. The structure of body_soil is identical to body. An additional restriction is that the minimum height of the soil resting on the bucket must correspond to the maximum height of a bucket wall.\nThe locations where there is soil resting on the bucket are stored in body_soil_pos as  3-elements vectors. The first element corresponds to the index of the sparse Matrix where the minimum height of the soil is stored, while the second and third element correspond to the index of the X and Y position, respectively.\nThe active areas (bucket_area, relax_area and impact_area) are assumed to be rectangular and to follow the grid geometry. They are thus stored as 2x2 Matrices where: [1, 1] corresponds to the minimum X index. [1, 2] corresponds to the maximum X index. [2, 1] corresponds to the minimum Y index. [2, 2] corresponds to the maximum Y index.\n\nNote\n\nCurrently, only one bucket at a time is supported, but this restriction may be removed in the future.\nSparse Matrices are used to reduce memory allocation and speed up calculation.\nAn attempt has been made to use Dicts instead of sparse Matrices, however Dicts seem to be prohibitively slow in that context, probably due to the size.\nequilibrium is a Vector of Bool instead of a Bool to make its value mutable.\n\nFields\n\nequilibrium::Vector{Bool}: Indicates whether the terrain is at equilibrium.\nterrain::Matrix{Float64}: Height of the terrain. [m]\nbody::Vector{SparseMatrixCSC{Float64,Int64}}: Store the vertical extension of all                                                 bucket walls for each XY position. [m]\nbody_soil::Vector{SparseMatrixCSC{Float64,Int64}}: Store the vertical extension of all                                                      soil resting on a bucket wall for                                                      each XY position. [m]\nbody_soil_pos::Vector{Vector{Int64}}: Store the indices of locations where there is                                         soil resting on the bucket.\nbucket_area::Matrix{Int64}: Store the 2D bounding box of the bucket with a buffer                               determined by the parameter cell_buffer of SimParam.\nrelax_area::Matrix{Int64}: Store the 2D bounding box of the area where soil has been                              relaxed with a buffer determined by the parameter                              cell_buffer of SimParam.\nimpact_area::Matrix{Int64}: Store the union of bucket_area and relax_area. It                               corresponds to the area where the soil equilibrium is                               checked.\n\nInner constructor\n\nSimOut(\n    terrain::Matrix{T}, grid::GridParam{I,T}\n) where {I<:Int64,T<:Float64}\n\nCreate a new instance of SimOut using the provided terrain.\n\nRequirements:\n\nThe terrain Matrix should be consistent with the grid size.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\n\nout = SimOut(terrain, grid)\n\nThis would create a flat terrain located at 0 height.\n\n\n\n\n\n","category":"type"},{"location":"types/#SoilDynamics.SimParam","page":"types.jl","title":"SoilDynamics.SimParam","text":"SimParam{I<:Int64,T<:Float64}\n\nStore all parameters related to the simulation.\n\nNote\n\nThe value of max_iterations should be carefully selected. A higher number will result in a terrain closer to equilibrium at the end of each time step, but it may impact significantly the performance of the simulator. A value of 3 is suggested.\n\nFields\n\nrepose_angle::Float64: The repose angle of the considered soil. [rad]\nmax_iterations::Int64: The maximum number of relaxation iterations per step.\ncell_buffer::Int64: The number of buffer cells surrounding the bucket and the relaxed                       terrain where soil equilibrium is checked.\n\nInner constructor\n\nSimParam(\n    repose_angle::T, max_iterations::I, cell_buffer::I,\n) where {I<:Int64,T<:Float64}\n\nCreate a new instance of SimParam.\n\nRequirements:\n\nThe repose_angle should be between 0.0 and pi / 2. The upper limit may be extended in the future.\nThe max_iterations should be greater or equal to zero.\nThe cell_buffer should be greater or equal to 2.\n\nExample\n\nsim = SimParam(0.85, 3, 4)\n\n\n\n\n\n","category":"type"}]
}
