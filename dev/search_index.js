var documenterSearchIndex = {"docs":
[{"location":"intersecting_cells/#Documentation-for-intersecting_cells.jl","page":"intersecting_cells.jl","title":"Documentation for intersecting_cells.jl","text":"","category":"section"},{"location":"intersecting_cells/","page":"intersecting_cells.jl","title":"intersecting_cells.jl","text":"Modules = [SoilDynamics]\nPages   = [\"intersecting_cells.jl\"]","category":"page"},{"location":"intersecting_cells/#SoilDynamics._locate_intersecting_cells-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._locate_intersecting_cells","text":"_locate_intersecting_cells(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function identifies all the soil cells in the terrain that intersect with the bucket.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices from the terrain intersecting with                          the bucket.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_locate_intersecting_cells(out)\n\n\n\n\n\n","category":"method"},{"location":"intersecting_cells/#SoilDynamics._move_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B}, Tuple{SimOut{B, I, T}, I, I, I, T, I, I, T, B, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._move_body_soil!","text":"_move_body_soil!(\n    out::SimOut{B,I,T}, ind_p::I, ii_p::I, jj_p::I, max_h::T, ii_n::I, jj_n::I,\n    h_soil::T, wall_presence::B, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function tries to move the soil cells resting on the bucket layer ind_p at the location (ii_p, jj_p) to a new location at (ii_n, jj_n).\n\nThis function can be separated into three main scenarios:\n\nIf all the soil can be moved to the new location (either on the terrain or on the bucket), the soil is moved and the value of h_soil is set to zero.\nIf a bucket wall is blocking the movement, the wall_presence parameter is set to true.\nIf there is insufficient space to move all the soil but no bucket wall is blocking the movement, the function updates the values for the new location and adjusts h_soil accordingly.\n\nThis function is designed to be used iteratively by _move_intersecting_body_soil! until all intersecting soil cells are moved.\n\nNote\n\nThis function is intended for internal use only.\nBy convention, the soil can be moved from the bucket to the terrain even if the bucket is underground.\nIn cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the _move_intersecting_body! function.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nind_p::Int64: Index of the previous considered bucket layer.\nii_p::Int64: Index of the previous considered position in the X direction.\njj_p::Int64: Index of the previous considered position in the Y direction.\nmax_h::Float64: Maximum height authorized for the movement. [m]\nii_n::Int64: Index of the new considered position in the X direction.\njj_n::Int64: Index of the new considered position in the Y direction.\nh_soil::Float64: Height of the soil column left to be moved. [m]\nwall_presence::Bool: Indicates whether a bucket wall is blocking the movement.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nind_p::Int64: Index of the new considered bucket layer.\nii_p::Int64: Index of the new considered position in the X direction.\njj_p::Int64: Index of the new considered position in the Y direction.\nh_soil::Float64: Height of the soil column left to be moved. [m]\nwall_presence::Bool: Indicates whether a bucket wall is blocking the movement.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n ind_p, ii_p, jj_p, h_soil, wall_presence = _move_body_soil!(\n     out, 1, 10, 15, 0.2, 10, 16, 0.2, true\n )\n\n\n\n\n\n","category":"method"},{"location":"intersecting_cells/#SoilDynamics._move_intersecting_body!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._move_intersecting_body!","text":"_move_intersecting_body!(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil cells in the terrain that intersect with a bucket. It checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces. If there is insufficient space for all the soil, it incrementally checks the eight directions farther from the intersecting soil column until all the soil has been moved. The process can be illustrated as follows\n\n             ↖   ↑   ↗\n               ↖ ↑ ↗\n             ← ← O → →\n               ↙ ↓ ↘\n             ↙   ↓   ↘\n\nNote\n\nThis function is intended for internal use only.\nThe order in which the directions are checked is randomized in order to avoid asymmetrical results.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_move_intersecting_body!(out)\n\n\n\n\n\n","category":"method"},{"location":"intersecting_cells/#SoilDynamics._move_intersecting_body_soil!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._move_intersecting_body_soil!","text":"_move_intersecting_body_soil!(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil cells resting on the bucket that intersect with another bucket layer. It checks the eight lateral directions surrounding the intersecting soil column and moves the soil to available spaces.\n\nThe algorithm follows an incremental approach, checking directions farther from the  intersecting soil column until it reaches a bucket wall blocking the movement or until all the soil has been moved. If the movement is blocked by a bucket wall, the algorithm explores another direction.\n\nIn cases where the soil should be moved to the terrain, all soil is moved regardless of the available space. If this movement induces intersecting soil cells, it will be resolved by the _move_intersecting_body! function.\n\nIn rare situations where there is insufficient space to accommodate all the intersecting soil, the algorithm currently handles it by allowing the excess soil to simply disappear. This compromise seems to be reasonable as long as the amount of soil disappearing remains negligible.\n\nNote\n\nThis function is intended for internal use only.\nThe order in which the directions are checked is randomized in order to avoid asymmetrical results.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_move_intersecting_body_soil!(out)\n\n\n\n\n\n","category":"method"},{"location":"intersecting_cells/#SoilDynamics._move_intersecting_cells!-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"intersecting_cells.jl","title":"SoilDynamics._move_intersecting_cells!","text":"_move_intersecting_cells!(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves all soil cells in terrain and in body_soil that intersect with the bucket or with another soil cell.\n\nNote\n\nThis function is intended for internal use only.\n_move_intersecting_body_soil! must be called before _move_intersecting_body!, otherwise some intersecting soil cells may remain.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_move_intersecting_cells!(out)\n\n\n\n\n\n","category":"method"},{"location":"body_soil/#Documentation-for-body_soil.jl","page":"body_soil.jl","title":"Documentation for body_soil.jl","text":"","category":"section"},{"location":"body_soil/","page":"body_soil.jl","title":"body_soil.jl","text":"Modules = [SoilDynamics]\nPages   = [\"body_soil.jl\"]","category":"page"},{"location":"body_soil/#SoilDynamics._update_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"body_soil.jl","title":"SoilDynamics._update_body_soil!","text":"_update_body_soil!(\n    out::SimOut{B,I,T}, pos::Vector{T}, ori::Quaternion{T}, grid::GridParam{I,T},\n    bucket::BucketParam{T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil resting on the bucket following its movement. To do so, the movement applied to the base of the soil column is calculated and the soil is moved to this new location. It is however difficult to track accurately each bucket wall. This is currently done by looking at the height difference between the previous and new soil locations, if this height difference is lower than cell_size_xy, it is assumed to be the same bucket wall. Some errors may however be present and further testing is required. If no bucket wall is present, the soil is moved down to the terrain.\n\nThe new positions of the soil resting on the bucket are collected into out.body_soil_pos and duplicates are removed.\n\nNote\n\nThis function is intended for internal use only.\nThis function is a work in progress. Some optimization and improvements may be needed.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\npos::Vector{Float64}: Cartesian coordinates of the bucket origin. [m]\nori::Quaternion{Float64}: Orientation of the bucket. [Quaternion]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nbucket::BucketParam{Float64}: Struct that stores information related to the                                 bucket object.\n\nOutputs\n\nNone\n\nExample\n\npos = [0.5, 0.3, 0.4]\nori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\nbucket = BucketParam(o, j, b, t, 0.5)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_update_body_soil!(out, pos, ori, grid, bucket)\n\n\n\n\n\n","category":"method"},{"location":"relax/#Documentation-for-relax.jl","page":"relax.jl","title":"Documentation for relax.jl","text":"","category":"section"},{"location":"relax/","page":"relax.jl","title":"relax.jl","text":"Modules = [SoilDynamics]\nPages   = [\"relax.jl\"]","category":"page"},{"location":"relax/#SoilDynamics._check_unstable_body_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T}, Tuple{SimOut{B, I, T}, I, I, I, I, I, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._check_unstable_body_cell","text":"_check_unstable_body_cell(\n    out::SimOut{B,I,T}, ii::I, jj::I, ind::I, ii_c::I, jj_c::I, h_min::T, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function checks the stability of a soil column in the soil layer ind of body_soil at (ii, jj) compared to one of its neighbor at (ii_c, jj_c). In case of instability, the function returns a two-digit number (status) that provides information on how the soil should avalanche. The interpretation of the two-digit number is described below.\n\nThe first digit indicates the potential presence of the bucket:\n\n1 when the first bucket layer is present.\n2 when the second bucket layer is present.\n3 when the two bucket layers are present.\n4 when no bucket layer is present.\n\nThe second digit indicates the layer where the soil should avalanche:\n\n0 when it is the terrain (no bucket is present).\n1 when it is the second bucket soil layer.\n2 when it is the second bucket layer.\n3 when it is the first bucket soil layer.\n4 when it is the first bucket layer.\n\nThe combination of these two digits provides a comprehensive description of how the soil should avalanche in different scenarios.\n\nNote\n\nThis function is intended for internal use only.\nNot all combinations for status are possible. Some combinations, such as 41 and 23 are impossible.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nii::Int64: Index of the considered cell in the X direction.\njj::Int64: Index of the considered cell in the Y direction.\nind::Int64: Index of the considered soil layer.\nii_c::Int64: Index of the neighboring cell in the X direction.\njj_c::Int64: Index of the neighboring cell in the Y direction.\nh_min::Float64: Minimum allowed height for a stable configuration. [m]\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nstatus::Int64: Two-digit number indicating how the soil should avalanche.                  0 is returned if the soil column is stable.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nstatus = _check_unstable_body_cell(out, 10, 14, 1, 10, 15, -0.1)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._check_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T}, Tuple{SimOut{B, I, T}, I, I, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._check_unstable_terrain_cell","text":"_check_unstable_terrain_cell(\n    out::SimOut{B,I,T}, ii_c::I, jj_c::I, h_min::T, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function checks the stability of a soil column in terrain compared to one of its neighbor (ii_c, jj_c). In case of instability, the function returns a three-digit number (status) that provides information on how the soil should avalanche. The interpretation of the three-digit number is described below.\n\nThe first digit indicates the potential presence of the bucket:\n\n1 when the first bucket layer is present.\n2 when the second bucket layer is present.\n3 when the two bucket layers are present.\n4 when no bucket layer is present.\n\nThe second digit indicates the layer at the top where the soil should avalanche:\n\n0 when it is the terrain (no bucket is present).\n1 when it is the second bucket soil layer.\n2 when it is the second bucket layer.\n3 when it is the first bucket soil layer.\n4 when it is the first bucket layer.\n\nThe third digit indicates whether the soil should avalanche below or above the bucket:\n\n0 when there is no bucket.\n1 when the soil should avalanche below the bucket.\n2 when the soil should avalanche on the top of the bucket.\n\nThe combination of these three digits provides a comprehensive description of how the soil should avalanche in different scenarios.\n\nNote\n\nThis function is intended for internal use only.\nNot all combinations for status are possible. Some combinations, such as 401, 231 and 220, are impossible.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nii_c::Int64: Index of the neighboring cell in the X direction.\njj_c::Int64: Index of the neighboring cell in the Y direction.\nh_min::Float64: Minimum allowed height for a stable configuration. [m]\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nstatus::Int64: Three-digit number indicating how the soil should avalanche.                  0 is returned if the soil column is stable.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nstatus = _check_unstable_terrain_cell(out, 10, 15, -0.1)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._locate_unstable_terrain_cell-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}, Tuple{SimOut{B, I, T}, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._locate_unstable_terrain_cell","text":"_locate_unstable_terrain_cell(\n    out::SimOut{B,I,T}, dh_max::T, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function locates all the cells in terrainthat have a height difference larger than dh_max with at least one neighboring cell. Such height difference may indicate that the soil column is unstable. However, it is important to note that this condition is not necessarily indicative of an actual soil instability, as a bucket or the soil resting on it could be supporting the soil column.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ndh_max::Float64: Maximum height difference allowed between two neighboring cells. [m]\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nunstable_cells::Vector{Vector{Int64}}: Collection of cells indices that are possibly                                          unstable.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nunstable_cells = _locate_unstable_terrain_cell(out, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._relax_body_soil!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._relax_body_soil!","text":"_relax_body_soil!(\n    out::SimOut{B,I,T}, grid::GridParam{I,T}, sim::SimParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil in body_soil towards a state closer to equilibrium. The soil stability is determined by the repose_angle. If the slope formed by two neighboring soil columns exceeds the repose_angle, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.\n\nBy convention, this function only checks the stability of the soil in the four adjacent cells:                      ↑                    ← O →                      ↓\n\nThe diagonal directions are not checked for simplicity and performance reasons.\n\nThis function only moves the soil when the following conditions are met:\n\n(1) The soil column in the neighboring cell is low enough. (2) There is space on the top of the neighboring soil column.\n\nNote\n\nThis function is intended for internal use only.\nThis function is a work in progress.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nsim::SimParam{Int64,Float64}: Struct that stores information related to the                                 simulation.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nsim = SimParam(0.85, 3, 4)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_relax_body_soil!(out, grid, sim)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._relax_terrain!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, GridParam{I, T}, SimParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._relax_terrain!","text":"_relax_terrain!(\n    out::SimOut{B,I,T}, grid::GridParam{I,T}, sim::SimParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil in terrain towards a state closer to equilibrium. The soil stability is determined by the repose_angle. If the slope formed by two neighboring soil columns exceeds the repose_angle, it is considered unstable, and the soil from the higher column should avalanche to the neighboring column to reach an equilibrium state.\n\nBy convention, this function only checks the stability of the soil in the four adjacent cells:                      ↑                    ← O →                      ↓\n\nThe diagonal directions are not checked for simplicity and performance reasons.\n\nThis function only moves the soil when the following conditions are met:\n\n(1) The soil column in the neighboring cell is low enough. (2) Either:         (a) The bucket is not on the soil, meaning there is space between the terrain and             the bucket, or there is no bucket.         (b) The bucket is on the terrain, but the combination of the bucket and bucket             soil is not high enough to prevent soil avalanche.\n\nIn case (2a), the soil will avalanche on the terrain, while in case (2b), the soil will avalanche on the bucket.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nsim::SimParam{Int64,Float64}: Struct that stores information related to the                                 simulation.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nsim = SimParam(0.85, 3, 4)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_relax_terrain!(out, grid, sim)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._relax_unstable_body_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, I, GridParam{I, T}}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, I, GridParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._relax_unstable_body_cell!","text":"_relax_unstable_body_cell!(\n    out::SimOut{B,I,T}, status::I, dh_max::T, ii::I, jj::I, ind::I, ii_c::I, jj_c::I,\n    grid::GridParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil from the soil layer ind of body_soil at (ii, jj) to the soil column in (ii_c, jj_c). The precise movement depends on the status number as explained in the _check_unstable_body_cell function.\n\nThe soil is moved such that the slope formed by the two neighboring soil columns is equal to the repose_angle, provided that the bucket is not preventing this configuration.\n\nNote\n\nThis function is intended for internal use only.\nIt is assumed that the given status is accurate, so no extra checks are present.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nstatus::Int64: Three-digit number indicating how the soil should avalanche.\ndh_max::Float64: Maximum height difference allowed between two neighboring cells. [m]\nii::Int64: Index of the considered cell in the X direction.\njj::Int64: Index of the considered cell in the Y direction.\nind::Int64: Index of the considered soil layer.\nii_c::Int64: Index of the neighboring cell in the X direction.\njj_c::Int64: Index of the neighboring cell in the Y direction.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_relax_unstable_body_cell!(out, 40, 0.1, 10, 15, 1, 10, 14, grid)\n\n\n\n\n\n","category":"method"},{"location":"relax/#SoilDynamics._relax_unstable_terrain_cell!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}}, Tuple{SimOut{B, I, T}, I, T, I, I, I, I, GridParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"relax.jl","title":"SoilDynamics._relax_unstable_terrain_cell!","text":"_relax_unstable_terrain_cell!(\n    out::SimOut{B,I,T}, status::I, dh_max::T, ii::I, jj::I, ii_c::I, jj_c::I,\n    grid::GridParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function moves the soil from the terrain at (ii, jj) to the soil column in (ii_c, jj_c). The precise movement depends on the status number as explained in the _check_unstable_terrain_cell function.\n\nThe soil is moved such that the slope formed by the two neighboring soil columns is equal to the repose_angle. When the bucket is preventing this configuration, the soil avalanche below the bucket to fill the space under it.\n\nNote\n\nThis function is intended for internal use only.\nIt is assumed that the given status is accurate, so no extra checks are present.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nstatus::Int64: Three-digit number indicating how the soil should avalanche.\ndh_max::Float64: Maximum height difference allowed between two neighboring cells. [m]\nii::Int64: Index of the considered cell in the X direction.\njj::Int64: Index of the considered cell in the Y direction.\nii_c::Int64: Index of the neighboring cell in the X direction.\njj_c::Int64: Index of the neighboring cell in the Y direction.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_relax_unstable_terrain_cell!(out, 131, 0.1, 10, 15, 10, 14, grid)\n\n\n\n\n\n","category":"method"},{"location":"utils/#Documentation-for-utils.jl","page":"utils.jl","title":"Documentation for utils.jl","text":"","category":"section"},{"location":"utils/","page":"utils.jl","title":"utils.jl","text":"Modules = [SoilDynamics]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"utils/#SoilDynamics._init_sparse_array!-Union{Tuple{T}, Tuple{I}, Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}, GridParam{I, T}}} where {I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics._init_sparse_array!","text":"_init_sparse_array!(\n    sparse_array::Vector{SparseMatrixCSC{T,I}}, grid::GridParam{I,T}\n) where {I<:Int64,T<:Float64}\n\nThis function reinitializes sparse_array. sparse_array is expected to be either body or body_soil.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nsparse_array::Vector{SparseMatrixCSC{Float64,Int64}}: Either body or body_soil.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_init_sparse_array!(out.body, grid)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics._locate_all_non_zeros-Union{Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}}, Tuple{T}, Tuple{I}} where {I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics._locate_all_non_zeros","text":"_locate_all_non_zeros(\n    sparse_array::Vector{SparseMatrixCSC{T,I}}\n) where {I<:Int64,T<:Float64}\n\nThis function returns the indices of all non-zero values in sparse_array. sparse_array is expected to be either body or body_soil.\n\nNote\n\nThis function is intended for internal use only.\nThe first index in the returned vector corresponds to the bucket layer, while the second and third indices are the indices in the X and Y direction, respectively.\n\nInputs\n\nsparse_array::Vector{SparseMatrixCSC{Float64,Int64}}: Either body or body_soil.\n\nOutputs\n\nVector{Vector{Int64}}:: Collection of cells indices where sparse_array is non-zero.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nbody_soil_pos = _locate_all_non_zeros(out.body_soil)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics._locate_non_zeros-Union{Tuple{SparseArrays.SparseMatrixCSC{T, I}}, Tuple{T}, Tuple{I}} where {I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics._locate_non_zeros","text":"_locate_non_zeros(\n    sparse_matrix::SparseMatrixCSC{T,I}\n) where {I<:Int64,T<:Float64}\n\nThis function returns the indices of all non-zero values in a sparse Matrix.\n\nNote\n\nThis function is intended for internal use only.\nThis implementation is faster than a simple loop.\n\nInputs\n\nsparse_matrix::SparseMatrixCSC{Float64,Int64}: Input Matrix for which non-zero values                                                  should be located.\n\nOutputs\n\nVector{Vector{Int64}}:: Collection of cells indices where the value of the input Matrix                           is non-zero.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\nnon_zeros = _locate_non_zeros(out.body[1])\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics._write_vector-Union{Tuple{T}, Tuple{Any, T, T, T}} where T<:Float64","page":"utils.jl","title":"SoilDynamics._write_vector","text":"_write_vector(\n    io, x::T, y::T, z::T\n) where {T<:Float64}\n\nThis is an utility function to write a 3D vector, such as Cartesian coordinates, into a file.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nio: Used as a refrence to the writing file.\nx::Float64: X coordinate of the position to write.\ny::Float64: Y coordinate of the position to write.\nz::Float64: Z coordinate of the position to write.\n\nOutputs\n\nNone\n\nExample\n\nopen(\"file.txt\", \"a\") do io\n    write_vector(io, 0.0, 0.0, 1.0)\nend\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.calc_normal-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T<:Float64","page":"utils.jl","title":"SoilDynamics.calc_normal","text":"calc_normal(\n    a::Vector{T}, b::Vector{T}, c::Vector{T}\n) where {T<:Float64}\n\nThis function calculates the unit normal vector of a plane formed by three points using the right-hand rule.\n\nNote\n\nThe input order of the points is important as it determines the sign of the unit normal vector based on the right-hand rule.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of the first point of the plane. [m]\nb::Vector{Float64}: Cartesian coordinates of the second point of the plane. [m]\nc::Vector{Float64}: Cartesian coordinates of the third point of the plane. [m]\n\nOutputs\n\nVector{T}: Unit normal vector of the provided plane. [m]\n\nExample\n\na = [0.0, 0.0, 0.0]\nb = [1.0, 0.5, 0.23]\nc = [0.1, 0.2, -0.5]\n\nunit_normal = calc_normal(a, b, c)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.check_soil-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics.check_soil","text":"check_soil(\n    out::SimOut{B,I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function checks that all the simulation outputs follow the conventions of the simulator. If any inconsistency is found, a warning is issued. The conventions that are checked include:\n\nThe terrain should not overlap with the bucket.\nThe bucket should be properly defined, with its maximum height higher than its minimum height.\nThe bucket soil should be properly defined, with its maximum height higher than its minimum height.\nThe two bucket layers should not overlap or touch each other.\nOne bucket layer should not overlap with all bucket soil layer.\nThe bucket should not overlap with the corresponding bucket soil layer.\nThe bucket soil layer should be resting on the corresponding bucket layer.\nThe bucket should be present when there is bucket soil.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\ncheck_soil(out)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.check_volume-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T, GridParam{I, T}}} where {B<:Bool, I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics.check_volume","text":"check_volume(\n    out::SimOut{B,I,T}, init_volume::T, grid::GridParam{I,T}\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function checks that the volume of soil is conserved. The intial volume of soil (init_volume) has to be provided.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ninit_volume::Float64: Initial volume of soil in the terrain. [m^3]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\ninit_volume = 0.0\n\ncheck_volume(out, init_volume, grid)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.set_RNG_seed!-Union{Tuple{}, Tuple{I}} where I<:Int64","page":"utils.jl","title":"SoilDynamics.set_RNG_seed!","text":"set_RNG_seed!(\n    seed::I=1234\n) where {I<:Int64}\n\nThis function sets the used RNG seed.\n\nInputs\n\nseed::Int64: Value of the RNG seed.\n\nOutputs\n\nNone\n\nExample\n\nset_RNG_seed!(1234)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.write_bucket-Union{Tuple{BucketParam{T}}, Tuple{T}} where T<:Float64","page":"utils.jl","title":"SoilDynamics.write_bucket","text":"write_bucket(\n    bucket::BucketParam{T}\n) where {T<:Float64}\n\nThis function writes the position of all bucket faces into a csv located in the \"results\" directory. The file is named \"bucket\" followed by the file number.\n\nInputs\n\nbucket::BucketParam{Float64}: Struct that stores information related to the                                 bucket object.\n\nOutputs\n\nNone\n\nExample\n\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\nbucket = BucketParam(o, j, b, t, 0.5)\n\nwrite_bucket(bucket)\n\n\n\n\n\n","category":"method"},{"location":"utils/#SoilDynamics.write_soil-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}}} where {B<:Bool, I<:Int64, T<:Float64}","page":"utils.jl","title":"SoilDynamics.write_soil","text":"write_soil(\n    out::SimOut{B,I,T}, grid::GridParam{I,T}\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function writes the terrain and the bucket soil into a csv located in the \"results\" directory. terrain and body_soil are saved into files named \"terrain\" and \"body_soil\", respectively, followed by the file number.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid\n\nwrite_soil(out, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#Documentation-for-bucket.jl","page":"bucket.jl","title":"Documentation for bucket.jl","text":"","category":"section"},{"location":"bucket/","page":"bucket.jl","title":"bucket.jl","text":"Modules = [SoilDynamics]\nPages   = [\"bucket.jl\"]","category":"page"},{"location":"bucket/#SoilDynamics._calc_bucket_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T}, Tuple{SimOut{B, I, T}, Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}, SimParam{I, T}, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_bucket_pos!","text":"_calc_bucket_pos!(\n    out::SimOut{B,I,T}, pos::Vector{T}, ori::Quaternion{T}, grid::GridParam{I,T},\n    bucket::BucketParam{I,T}, sim::SimParam{I,T}, step_bucket_grid::T=0.5, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function determines all the cells where the bucket is located. The bucket position is calculated based on its reference pose stored in the bucket struct, as well as the provided position (pos) and orientation (ori). pos and ori are used to apply the appropriate translation and rotation to the bucket relative to its reference pose. The center of rotation is assumed to be the bucket origin. The orientation is provided using the quaternion definition.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\npos::Vector{Float64}: Cartesian coordinates of the bucket origin. [m]\nori::Quaternion{Float64}: Orientation of the bucket. [Quaternion]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\nbucket::BucketParam{Float64}: Struct that stores information related to the                                 bucket object.\nsim::SimParam{Int64,Float64}: Struct that stores information related to the                                 simulation.\nstep_bucket_grid::Float64: Spatial increment used to decompose the edges of the bucket.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\npos = [0.5, 0.3, 0.4]\nori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\nbucket = BucketParam(o, j, b, t, 0.5)\nsim = SimParam(0.85, 3, 4)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_calc_bucket_pos!(out, pos, ori, grid, bucket, sim)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_line_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, T, GridParam{I, T}}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_line_pos","text":"_calc_line_pos(\n    a::Vector{T}, b::Vector{T}, delta::T, grid::GridParam{I,T}\n) where {I<:Int64,T<:Float64}\n\nThis function determines all the cells that lie on a straight line between two Cartesian coordinates.\n\nFor the sake of accuracy, the line is divided into smaller segments using a spatial increment delta.\n\nThe coordinates of each sub-point (ab_i) along the line can then be calculated as\n\nab_i = a + ab * i * delta / norm(ab)\n\nwhere i is the increment number and ab = b - a. The Cartesian coordinates can then be converted into indices\n\nab_i_ind = ab_i / cell_size + grid_half_length + 1\n\nFinally, the floating-point values are rounded to obtain the cell indices in the X, Y, Z directions. As the center of each cell is considered to be on the center of the top surface, round should be used for getting the cell indices in the X and Y direction, while ceil should be used for the Z direction.\n\nNote\n\nThis function is intended for internal use only.\nWhen the line follows a cell border, the exact location of the line becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of the first extremity of the line. [m]\nb::Vector{Float64}: Cartesian coordinates of the second extremity of the line. [m]\ndelta::Float64: Spatial increment used to decompose the line. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\n\nOutputs\n\nline_pos::Vector{Vector{Int64}}: Collection of cells indices where the line is located.                                    Result is not sorted and duplicates should be expected.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.5, 0.7]\nb = [0.7, 0.8, -0.3]\n\nline_pos = _calc_line_pos(a, b, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_rectangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_rectangle_pos","text":"_calc_rectangle_pos(\n    a::Vector{T}, b::Vector{T}, c::Vector{T}, d::Vector{T},\n    delta::T, grid::GridParam{I,T}, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function determines the cells where a rectangle surface is located. The rectangle is defined by providing the Cartesian coordinates of its four vertices in the proper order.\n\nTo optimize performance, the function iterates over a portion of the horizontal grid where the rectangle is located. For each cell, the function calculates the height of the plane formed by the rectangle at the top right corner of the cell. If the cell is within the rectangle area, the calcualted height is added to the results for the four neighboring cells.\n\nThis method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.\n\nHowever, this approach does not work when the rectangle is perpendicular to the XY plane. To handle this case, the function uses the _calc_line_pos function to include the cells that lie on the four edges of the rectangle.\n\nNote\n\nThis function is intended for internal use only.\nThe iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.\nNot all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.\nWhen the rectangle follows a cell border, the exact location of the rectangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nb::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nc::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\nd::Vector{Float64}: Cartesian coordinates of one vertex of the rectangle. [m]\ndelta::Float64: Spatial increment used to decompose the edges of the rectangle. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices where the rectangle is located.                          Result is not sorted and duplicates may be present.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.0, 0.7]\nb = [0.0, 1.0, 0.7]\nc = [0.0, 1.0, 0.9]\nd = [1.0, 0.0, 0.9]\n\nrect_pos = _calc_rectangle_pos(a, b, c, d, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._calc_triangle_pos-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}}, Tuple{Vector{T}, Vector{T}, Vector{T}, T, GridParam{I, T}, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._calc_triangle_pos","text":"_calc_triangle_pos(\n    a::Vector{T}, b::Vector{T}, c::Vector{T},\n    delta::T, grid::GridParam{I,T}, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function determines the cells where a triangle surface is located. The triangle is defined by providing the Cartesian coordinates of its three vertices in the proper order.\n\nTo optimize performance, the function iterates over a portion of the horizontal grid where the triangle is located. For each cell, the function calculates the height of the plane formed by the triangle at the top right corner of the cell. If the cell is within the triangle area, the calcualted height is added to the results for the four neighboring cells.\n\nThis method works because when a plane intersects with a rectangular cell, the minimum and maximum height of the plane within the cell occurs at one of the cell corners. By iterating through all the cells, the function ensures that all the corners of each cell are investigated.\n\nHowever, this approach does not work when the triangle is perpendicular to the XY plane. To handle this case, the function uses the _calc_line_pos function to include the cells that lie on the three edges of the triangle.\n\nNote\n\nThis function is intended for internal use only.\nThe iteration is performed over the top right corner of each cell, but any other corner could have been chosen without affecting the results.\nNot all cells are provided, since, at a given XY position, only the cells with the minimum and maximum height are important.\nWhen the triangle follows a cell border, the exact location of the triangle becomes ambiguous. It is assumed that the caller resolves this ambiguity.\n\nInputs\n\na::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\nb::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\nc::Vector{Float64}: Cartesian coordinates of one vertex of the triangle. [m]\ndelta::Float64: Spatial increment used to decompose the edges of the triangle. [m]\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nVector{Vector{Int64}}: Collection of cells indices where the triangle is located.                          Result is not sorted and duplicates may be present.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\na = [1.0, 0.0, 0.7]\nb = [0.0, 1.0, 0.7]\nc = [0.0, 1.0, 0.9]\n\ntri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._decompose_vector_rectangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._decompose_vector_rectangle","text":"_decompose_vector_rectangle(\n    ab_ind::Vector{T}, ad_ind::Vector{T}, a_ind::Vector{T},\n    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function performs a vector decomposition on a portion of the horizontal plane where a rectangle ABCD is located. The position of the rectangle is defined by its edges AB and AD, while the specified area extends over [area_min_x, area_min_x + area_length_x] on the X direction and [area_min_y, area_min_y + area_length_y] on the Y direction.\n\nFor each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AD. Let O be the name of a cell, it can then be decomposed as\n\nAO = c_ab * AB + c_ad * AD.\n\nThis decomposition leads to a system of 2 equations with 2 unknowns (cab and cad)\n\nAO[1] = c_ab * AB[1] + c_ad * AD[1] {1},\nAO[2] = c_ab * AB[2] + c_ad * AD[2] {2}.\n\nOne may note that AB[1] * {2} - AB[2] * {1} implies that\n\nAB[1] * AO[2] - AB[2] * AO[1] = c_ad * AD[2] * AB[1] - c_ad * AD[1] * AB[2]\n\nthat can be further rewritten as\n\nc_ad = (AB[1] * AO[2] - AB[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).\n\nSimilarly, AD[1] * {2} - AD[2] * {1} implies that\n\nc_ab = -(AD[1] * AO[2] - AD[2] * AO[1]) / (AD[2] * AB[1] - AD[1] * AB[2]).\n\nThis decomposition allows us to determine whether the cell O is inside the rectangle area, since this requires cab and cad to be between 0 and 1.\n\nNote\n\nThis function is intended for internal use only.\nBy convention, the decomposition is done at the top right corner of each cell.\n\nInputs\n\nab_ind::Vector{Float64}: Indices representing the edge AB of the rectangle.\nad_ind::Vector{Float64}: Indices representing the edge AD of the rectangle.\na_ind::Vector{Float64}: Indices of the vertex A from which the edges AB and AD start.\narea_min_x::Int64: Minimum index in the X direction of the specified area.\narea_min_y::Int64: Minimum index in the Y direction of the specified area.\narea_length_x::Int64: Number of grid elements in the X direction of the specified area.\narea_length_y::Int64: Number of grid elements in the Y direction of the specified area.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nc_ab::Matrix{Float64}: Results of the vector decomposition in terms of the AB component.\nc_ad::Matrix{Float64}: Results of the vector decomposition in terms of the AD component.\nin_rectangle::Matrix{Bool}: Indicates whether the cell is inside the rectangle area.\nn_cell::Int64: Number of cells inside the rectangle area.\n\nExample\n\nab_ind = [0, 4, 0]\nad_ind = [3, 0, 0]\na_ind = [10, 8, 25]\n\nc_ab, c_ad, in_rectangle, n_cell = _decompose_vector_rectangle(\n    ab_ind, ad_ind, a_ind, 15, 12, 8, 7\n)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._decompose_vector_triangle-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I}, Tuple{Vector{T}, Vector{T}, Vector{T}, I, I, I, I, T}} where {I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._decompose_vector_triangle","text":"_decompose_vector_triangle(\n    ab_ind::Vector{T}, ac_ind::Vector{T}, a_ind::Vector{T},\n    area_min_x::I, area_min_y::I, area_length_x::I, area_length_y::I, tol::T=1e-8\n) where {I<:Int64,T<:Float64}\n\nThis function performs a vector decomposition on a portion of the horizontal plane where a triangle ABC is located. The position of the triangle is defined by its edges AB and AC , while the specified area extends over [area_min_x, area_min_x + area_length_x] on the X direction and [area_min_y, area_min_y + area_length_y] on the Y direction.\n\nFor each cell in the specified area, the function decomposes it into the basis formed by the vectors AB and AC. Let O be the name of a cell, it can then be decomposed as\n\nAO = c_ab * AB + c_ac * AC.\n\nThis decomposition leads to a system of 2 equations with 2 unknowns (cab and cac)\n\nAO[1] = c_ab * AB[1] + c_ac * AC[1] {1},\nAO[2] = c_ab * AB[2] + c_ac * AC[2] {2}.\n\nOne may note that AB[1] * {2} - AB[2] * {1} implies that\n\nAB[1] * AO[2] - AB[2] * AO[1] = c_ac * AC[2] * AB[1] - c_ac * AC[1] * AB[2]\n\nthat can be further rewritten as\n\nc_ac = (AB[1] * AO[2] - AB[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).\n\nSimilarly, AC[1] * {2} - AC[2] * {1} implies that\n\nc_ab = -(AC[1] * AO[2] - AC[2] * AO[1]) / (AC[2] * AB[1] - AC[1] * AB[2]).\n\nThis decomposition allows us to determine whether the cell O is inside the triangle area, since this requires cab and cac to be between 0 and 1, and the sum of cab and cac to be lower than 1.\n\nNote\n\nThis function is intended for internal use only.\nBy convention, the decomposition is done at the top right corner of each cell.\n\nInputs\n\nab_ind::Vector{Float64}: Indices representing the edge AB of the triangle.\nac_ind::Vector{Float64}: Indices representing the edge AC of the triangle.\na_ind::Vector{Float64}: Indices of the vertex A from which the edges AB and AC start.\narea_min_x::Int64: Minimum index in the X direction of the specified area.\narea_min_y::Int64: Minimum index in the Y direction of the specified area.\narea_length_x::Int64: Number of grid elements in the X direction of the specified area.\narea_length_y::Int64: Number of grid elements in the Y direction of the specified area.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nc_ab::Matrix{Float64}: Results of the vector decomposition in terms of the AB component.\nc_ac::Matrix{Float64}: Results of the vector decomposition in terms of the AC component.\nin_triangle::Matrix{Bool}: Indicates whether the cell is inside the triangle area.\nn_cell::Int64: Number of cells inside the triangle area.\n\nExample\n\nab_ind = [0, 4, 0]\nac_ind = [3, 0, 0]\na_ind = [10, 8, 25]\n\nc_ab, c_ac, in_triangle, n_cell = _decompose_vector_triangle(\n    ab_ind, ac_ind, a_ind, 15, 12, 8, 7\n)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._include_new_body_pos!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, I, I, T, T}, Tuple{SimOut{B, I, T}, I, I, T, T, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._include_new_body_pos!","text":"_include_new_body_pos!(\n    out::SimOut{B,I,T}, ii::I, jj::I, min_h::T, max_h::T, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function updates the bucket position in body at the coordinates (ii, jj). The minimum and maximum heights of the bucket at that position are given by min_h and max_h, respectively. If the given position overlaps with an existing position, then the existing position is updated as the union of the two positions. Otherwise, a new position is added to body.\n\nNote\n\nThis function is intended for internal use only.\n\nInputs\n\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\nii::Int64: Index of the considered position in the X direction.\njj::Int64: Index of the considered position in the Y direction.\nmin_h::Float64: Minimum height of the bucket. [m]\nmax_h::Float64: Maximum height of the bucket. [m]\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\n\n_include_new_body_pos!(out, 10, 15, 0.5, 0.6)\n\n\n\n\n\n","category":"method"},{"location":"bucket/#SoilDynamics._update_body!-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}}, Tuple{Array{Vector{I}, 1}, SimOut{B, I, T}, GridParam{I, T}, T}} where {B<:Bool, I<:Int64, T<:Float64}","page":"bucket.jl","title":"SoilDynamics._update_body!","text":"_update_body!(\n    area_pos::Vector{Vector{I}}, out::SimOut{B,I,T}, grid::GridParam{I,T}, tol::T=1e-8\n) where {B<:Bool,I<:Int64,T<:Float64}\n\nThis function updates the bucket position in body following the cells composing area_pos. For each XY position, the first cell found in area_pos corresponds to the minimum height of the bucket, while the last one provides the maximum height. As a result, this function must be called separately for each bucket wall.\n\nNote\n\nThis function is intended for internal use only.\narea_pos must be sorted and not be empty.\n\nInputs\n\narea_pos::Vector{Vector{Int64}}: A collection of cell indices specifying where a bucket                                    wall is located.\nout::SimOut{Bool,Int64,Float64}: Struct that stores simulation outputs.\ngrid::GridParam{Int64,Float64}: Struct that stores information related to the                                   simulation grid.\ntol::Float64: Small number used to handle numerical approximation errors.\n\nOutputs\n\nNone\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\nout = SimOut(terrain, grid)\na = [1.0, 0.0, 0.7]\nb = [0.0, 1.0, 0.7]\nc = [0.0, 1.0, 0.9]\ntri_pos = _calc_triangle_pos(a, b, c, 0.01, grid)\n\n_update_body!(tri_pos, out, grid)\n\n\n\n\n\n","category":"method"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"types/#Documentation-for-types.jl","page":"types.jl","title":"Documentation for types.jl","text":"","category":"section"},{"location":"types/","page":"types.jl","title":"types.jl","text":"Modules = [SoilDynamics]\nPages   = [\"types.jl\"]","category":"page"},{"location":"types/#SoilDynamics.BucketParam","page":"types.jl","title":"SoilDynamics.BucketParam","text":"BucketParam{T<:Float64}\n\nStore all parameters related to a bucket object.\n\nConvention\n\nThe bucket is approximated as a triangular prism\n               A ____________________ D\n              /.                     /|\n             / .                    / |\n            /  .                   /  |\n           /   .                  /   |\n          /    .                 /    |\n         /     .                /     |\n        /      .               /      |\n       /       C . . . . . .  / . . . F\n      /      .               /        ̸\n     /     .                /       ̸\n    /    .                 /      ̸\n   /   .                  /     ̸\n  /  .                   /    ̸\n / .                    /   ̸\nB ____________________ E\nThe middle of the segment AD is referred to as the bucket \"joint\".\nThe middle of the segment CF is referred to as the bucket \"base\".\nThe middle of the segment BE is referred to as the bucket \"teeth\".\nThe surface ABED is open and referred to as the bucket \"front\".\nThe surface BCFE is a bucket wall and referred to as the bucket \"base\".\nThe surface ACFD is a bucket wall and referred to as the bucket \"back\".\nThe surface ABC is a bucket wall and referred to as the bucket \"right side\".\nThe surface DEF is a bucket wall and referred to as the bucket \"left side\".\nThe bucket has a constant width, denoted as\nAD = BE = CF = width.\nThe center of rotation of the bucket is assumed to be at the bucket \"origin\" (not shown in the figure) and the bucket vertices are given relative to this origin.\nThe provided coordinates are assumed to be the reference pose of the bucket, from which the bucket pose is calculated throughout the code.\n\nFields\n\nj_pos_init::Vector{Float64}: Cartesian coordinates of the bucket joint in its                                reference pose. [m]\nb_pos_init::Vector{Float64}: Cartesian coordinates of the bucket base in its                                reference pose. [m]\nt_pos_init::Vector{Float64}: Cartesian coordinates of the bucket teeth in its                                reference pose. [m]\nwidth::Float64: Width of the bucket. [m]\npos::Vector{Float64}: Cartesian coordinates of the bucket origin. [m]\nori::Vector{Float64}: Orientation of the bucket. Note that it is stored as a Vector,                         since Quaternions are not mutable. [Quaternion]\n\nInner constructor\n\nBucketParam(\n    o_pos_init::Vector{T}, j_pos_init::Vector{T}, b_pos_init::Vector{T},\n    t_pos_init::Vector{T}, width::T\n) where {T<:Float64}\n\nCreate a new instance of BucketParam using the reference positions of the bucket origin, joint, base, and teeth as well as the bucket width. The position of the bucket joint, base, and teeth are given relative to the position of the bucket origin.\n\nRequirements:\n\nAll provided Cartesian coordinates should be a vector of size 3.\nThe bucket joint, base and teeth should have strictly different location.\nThe bucket width should be greater than zero.\n\nExample\n\no = [0.0, 0.0, 0.0]\nj = [0.0, 0.0, 0.0]\nb = [0.0, 0.0, -0.5]\nt = [1.0, 0.0, -0.5]\n\nbucket = BucketParam(o, j, b, t, 0.5)\n\nThis would create a bucket ABCDEF with its center of rotation at the bucket joint and with A = [0.0, -0.25, 0.0], B = [1.0, -0.25, -0.5], C = [0.0, -0.25, -0.5] D = [0.0, 0.25, 0.0], E = [1.0, 0.25, -0.5], F = [0.0, 0.25, -0.5].\n\n\n\n\n\n","category":"type"},{"location":"types/#SoilDynamics.GridParam","page":"types.jl","title":"SoilDynamics.GridParam","text":"GridParam{I<:Int64,T<:Float64}\n\nStore all parameters related to the simulation grid.\n\nConvention\n\nThe simulation grid is centred at 0, that is, if the extent of the grid is 10.0, the grid would then extend from -5.0 to 5.0, this applies to all direction.\nThe grid is composed of regular 3D cells\n          H-----------G\n         /           /|\n        /     O     / |\n       /           /  |\n      E-----------F   C\n      |           |  /\n      |           | /\n      |           |/\n      A-----------B\nThe cells have the same size in both lateral direction\nAB = BC = CD = DA = EF = FG = GH = HE,\nwhile their height can potentially be lower\nAE = BF = CG = DH <= AB.\nThe center of each cell (O) is considered to be at the center of the top surface.\nThe considered reference frame follows the right-hand rule, with the Z direction pointing upward.\n\nFields\n\nhalf_length_x::Int64: Number of grid elements in the positive (or negative) X direction.\nhalf_length_y::Int64: Number of grid elements in the positive (or negative) Y direction.\nhalf_length_z::Float64: Number of grid elements in the positive (or negative) Z                           direction. Note that it is a Float.\ncell_size_xy::Float64: Size of the cells in the X and Y direction. [m]\ncell_size_z::Float64: Height of the cells in the Z direction. [m]\ncell_area::Float64: Surface area of one cell in the horizontal plane. [m^2]\ncell_volume::Float64: Volume of one cell. [m^3]\nvect_x::StepRangeLen{Float64}: Vector providing a conversion between cell's index and                                  cell's position in the X direction.\nvect_y::StepRangeLen{Float64}: Vector providing a conversion between cell's index and                                  cell's position in the Y direction.\nvect_z::StepRangeLen{Float64}: Vector providing a conversion between cell's index and                                  cell's position in the Z direction.\n\nInner constructor\n\nGridParam(\n    grid_size_x::T, grid_size_y::T, grid_size_z::T, cell_size_xy::T,\n    cell_size_z::T=cell_size_xy\n) where {T<:Float64}\n\nCreate a new instance of GridParam using the grid size in [m]. The actual size of the grid would be:\n\n[-gridsizex, gridsizex] in the X direction.\n[-gridsizey, gridsizey] in the Y direction.\n[-gridsizez, gridsizez] in the Z direction.\n\nRequirements:\n\nAll inputs should be greater than zero.\ncellsizexy should be lower than or equal to gridsizex and gridsizey.\ncellsizez should be lower than or equal to gridsizez.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\n\nThis would create a grid of size [-4, 4] in the X direction, [-4, 4] in the Y direction, [-3, 3] in the Z direction, and with cells of size 0.05 x 0.05 x 0.01 in the XYZ direction.\n\n\n\n\n\n","category":"type"},{"location":"types/#SoilDynamics.SimOut","page":"types.jl","title":"SoilDynamics.SimOut","text":"SimOut{B<:Bool,I<:Int64,T<:Float64}\n\nStore all outputs of the simulation.\n\nConvention\n\nThe terrain Matrix stores the height of the terrain at each XY position, see the GridParam struct for more information on the simulation grid.\nThe cells where a bucket wall is located is stored in body, which is a vector of sparse Matrices. At each XY position, the first sparse Matrix indicates the lowest height where a bucket wall is located while the second sparse Matrix indicates the maximum height of this bucket wall. If a second bucket wall is located at the same XY position, its minimum and maximum height are indicated in the third and fourth sparse Matrix, respectively.\nFor each bucket, there can be only two distinct bucket walls located at the same XY position. As a result, the number of sparse Matrices in the body vector should be equal to four times the number of bucket.\nSimilarly, body_soil stores the location of the soil resting on a bucket wall. The structure of body_soil is identical to body. An additionnal restriction is that the minimum height of the soil resting on the bucket must correspond to the maximum height of a bucket wall.\nThe locations where there is soil resting on the bucket are stored in body_soil_pos as  3-elements vectors. The first element corresponds to the index of the sparse Matrix where the minimum height of the soil is stored, while the second and third element correspond to the index of the X and Y position, respectively.\nThe active areas (bucket_area, relax_area and impact_area) are assumed to be rectangular and to follow the grid geometry. They are thus stored as 2x2 Matrices where: [1, 1] corresponds to the minimum X index. [1, 2] corresponds to the maximum X index. [2, 1] corresponds to the minimum Y index. [2, 2] corresponds to the maximum Y index.\n\nNote\n\nCurrently, only one bucket at a time is supported, but this restriction may be removed in the future.\nSparse Matrices are used to reduce memory allocation and speed up calculation.\nAn attempt has been made to use Dicts instead of sparse Matrices, however Dicts seem to be prohibitively slow in that context, probably due to the size.\nequilibrium is a Vector of Bool instead of a Bool to make its value mutable.\n\nFields\n\nequilibrium::Vector{Bool}: Indicates whether the terrain is at equilibrium.\nterrain::Matrix{Float64}: Height of the terrain. [m]\nbody::Vector{SparseMatrixCSC{Float64,Int64}}: Store the vertical extension of all                                                 bucket walls for each XY position. [m]\nbody_soil::Vector{SparseMatrixCSC{Float64,Int64}}: Store the vertical extension of all                                                      soil resting on a bucket wall for                                                      each XY position. [m]\nbody_soil_pos::Vector{Vector{Int64}}: Store the indices of locations where there is                                         soil resting on the bucket.\nbucket_area::Matrix{Int64}: Store the 2D bounding box of the bucket with a buffer                               determined by the parameter cell_buffer of SimParam.\nrelax_area::Matrix{Int64}: Store the 2D bounding box of the area where soil has been                              relaxed with a buffer determined by the parameter                              cell_buffer of SimParam.\nimpact_area::Matrix{Int64}: Store the union of bucket_area and relax_area. It                               corresponds to the area where the soil equilibrium is                               checked.\n\nInner constructor\n\nSimOut(\n    terrain::Matrix{T}, grid::GridParam{I,T}\n) where {I<:Int64,T<:Float64}\n\nCreate a new instance of SimOut using the provided terrain.\n\nRequirements:\n\nThe terrain Matrix should be consistent with the grid size.\n\nExample\n\ngrid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)\nterrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)\n\nout = SimOut(terrain, grid)\n\nThis would create a flat terrain located at 0 height.\n\n\n\n\n\n","category":"type"},{"location":"types/#SoilDynamics.SimParam","page":"types.jl","title":"SoilDynamics.SimParam","text":"SimParam{I<:Int64,T<:Float64}\n\nStore all parameters related to the simulation.\n\nNote\n\nThe value of max_iterations should be carefully selected. A higher number will result in a terrain closer to equilibrium at the end of each time step, but it may impact significantly the performance of the simulator. A value of 3 is suggested.\n\nFields\n\nrepose_angle::Float64: The repose angle of the considered soil. [rad]\nmax_iterations::Int64: The maximum number of relaxation iterations per step.\ncell_buffer::Int64: The number of buffer cells surrounding the bucket and the relaxed                       terrain where soil equilibrium is checked.\n\nInner constructor\n\nSimParam(\n    repose_angle::T, max_iterations::I, cell_buffer::I,\n) where {I<:Int64,T<:Float64}\n\nCreate a new instance of SimParam.\n\nRequirements:\n\nThe repose_angle should be between 0.0 and pi / 2. The upper limit may be extended in the future.\nThe max_iterations should be greater or equal to zero.\nThe cell_buffer should be greater or equal to 2.\n\nExample\n\nsim = SimParam(0.85, 3, 4)\n\n\n\n\n\n","category":"type"}]
}
