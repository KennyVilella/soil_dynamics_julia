<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>utils.jl · Soil dynamics simulator</title><meta name="title" content="utils.jl · Soil dynamics simulator"/><meta property="og:title" content="utils.jl · Soil dynamics simulator"/><meta property="twitter:title" content="utils.jl · Soil dynamics simulator"/><meta name="description" content="Documentation for Soil dynamics simulator."/><meta property="og:description" content="Documentation for Soil dynamics simulator."/><meta property="twitter:description" content="Documentation for Soil dynamics simulator."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Soil dynamics simulator</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">types.jl</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../bucket/">bucket.jl</a></li><li><a class="tocitem" href="../body_soil/">body_soil.jl</a></li><li><a class="tocitem" href="../intersecting_cells/">intersecting_cells.jl</a></li><li><a class="tocitem" href="../relax/">relax.jl</a></li><li class="is-active"><a class="tocitem" href>utils.jl</a><ul class="internal"><li><a class="tocitem" href="#Checking-functions"><span>Checking functions</span></a></li><li><a class="tocitem" href="#Writing-functions"><span>Writing functions</span></a></li><li><a class="tocitem" href="#_locate_all_non_zeros"><span><code>_locate_all_non_zeros</code></span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>utils.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>utils.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/KennyVilella/soil_dynamics_julia" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/main/docs/src/utils.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation-for-utils.jl"><a class="docs-heading-anchor" href="#Documentation-for-utils.jl">Documentation for utils.jl</a><a id="Documentation-for-utils.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-for-utils.jl" title="Permalink"></a></h1><p>This file aggregates a collection of utility functions. Information for some of these functions are provided below.</p><h2 id="Checking-functions"><a class="docs-heading-anchor" href="#Checking-functions">Checking functions</a><a id="Checking-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-functions" title="Permalink"></a></h2><p>This corresponds to the functions <code>check_volume</code> and <code>check_soil</code>, which can be used to check the validity of the simulation outputs. It is important to call these functions either before or after the simulation stepping process, as the outputs may be temporarily invalid during the stepping.</p><p>The <code>check_volume</code> function verifies mass conservation, ensuring that the total mass of soil is properly conserved throughout the simulation.  The <code>check_soil</code> function checks the coherence and integrity of the terrain, bucket soil, and bucket. It ensures that there are no intersections or conflicting cell assignments between these three groups.</p><p>Note that these functions are computationally intensive and may slow down the simulation. Therefore, it is recommended to use them primarily for debugging and testing purposes.</p><h2 id="Writing-functions"><a class="docs-heading-anchor" href="#Writing-functions">Writing functions</a><a id="Writing-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-functions" title="Permalink"></a></h2><p>This corresponds to the functions <code>write_soil</code> and <code>write_bucket</code>, which can be used to write the outputs into csv files. The <code>write_bucket</code> function generates files starting with <code>bucket</code>, containing the Cartesian coordinates of the four bucket walls&#39; edges. Conversely, the <code>write_soil</code> function generates files starting with <code>terrain</code> for the terrain height and <code>body_soil</code> for the bucket soil height. All the output files are saved in the <code>results</code> folder, with sequentially increasing numbers appended to the filenames.</p><p>Note that these functions are primarily designed to be used in the example script provided. Consequently, they have potential limitations that should be considered by the user. Firstly, the file numbers are assigned sequentially. If the <code>write_bucket</code> and <code>write_soil</code> functions are not called together consistently, the file numbers of the <code>bucket</code> and <code>terrain</code> may not correspond. Additionally, this may cause issues if existing files are present in the <code>results</code> folder.</p><p>Secondly, the file formats generated by these functions are specifically designed for visualization with Paraview. To visualize the data using a different tool, some change to the file formats may be needed.</p><h2 id="_locate_all_non_zeros"><a class="docs-heading-anchor" href="#_locate_all_non_zeros"><code>_locate_all_non_zeros</code></a><a id="_locate_all_non_zeros-1"></a><a class="docs-heading-anchor-permalink" href="#_locate_all_non_zeros" title="Permalink"></a></h2><p>The purpose of this function is to provide a list of indices corresponding to the non-zero elements of either the <code>body</code> or <code>body_soil</code> field of the <code>SimOut</code> struct. <code>body</code> and <code>body_soil</code> are a vector of Sparse Matrices indicating the location of the bucket and bucket soil, respectively. Sparse Matrices are used to speed up the code and reduce memory allocation, but this function is still slow and should be used only when necessary.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._calc_bucket_corner_pos-Union{Tuple{T}, Tuple{Vector{T}, ReferenceFrameRotations.Quaternion{T}, BucketParam{T}}} where T&lt;:Float64" href="#SoilDynamics._calc_bucket_corner_pos-Union{Tuple{T}, Tuple{Vector{T}, ReferenceFrameRotations.Quaternion{T}, BucketParam{T}}} where T&lt;:Float64"><code>SoilDynamics._calc_bucket_corner_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_bucket_corner_pos(
    pos::Vector{T}, ori::Quaternion{T}, bucket::BucketParam{T}
) where {T&lt;:Float64}</code></pre><p>This function calculates the global position of the six corners of the bucket.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>pos::Vector{Float64}</code>: Cartesian coordinates of the bucket origin. [m]</li><li><code>ori::Quaternion{Float64}</code>: Orientation of the bucket. [Quaternion]</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Float64}</code>: Cartesian coordinates of the right side of the bucket joint. [m]</li><li><code>Vector{Float64}</code>: Cartesian coordinates of the left side of the bucket joint. [m]</li><li><code>Vector{Float64}</code>: Cartesian coordinates of the right side of the bucket base. [m]</li><li><code>Vector{Float64}</code>: Cartesian coordinates of the left side of the bucket base. [m]</li><li><code>Vector{Float64}</code>: Cartesian coordinates of the right side of the bucket teeth. [m]</li><li><code>Vector{Float64}</code>: Cartesian coordinates of the left side of the bucket teeth. [m]</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">pos = [0.1, 0.0, 0.2]
ori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)
o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)

j_r_pos, j_l_pos, b_r_pos, b_l_pos, t_r_pos, t_l_pos = _calc_bucket_corner_pos(
    pos, ori, bucket
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L9-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._calc_bucket_frame_pos-Union{Tuple{T}, Tuple{I}, Tuple{I, I, T, GridParam{I, T}, BucketParam{T}}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._calc_bucket_frame_pos-Union{Tuple{T}, Tuple{I}, Tuple{I, I, T, GridParam{I, T}, BucketParam{T}}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._calc_bucket_frame_pos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_calc_bucket_frame_pos(
    ii::I, jj::I, z::T, grid::GridParam{I,T}, bucket::BucketParam{T}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function calculates the position of a considered cell in the bucket frame assuming that the bucket is in its reference position.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>ii::Int64</code>: Index of the considered cell in the X direction.</li><li><code>jj::Int64</code>: Index of the considered cell in the Y direction.</li><li><code>z::Float64</code>: Height of the considered position. [m]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Float64}</code>: Cartesian coordinates of the considered position in the reference                    bucket frame. [m]</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)
grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)

cell_local_pos = _calc_bucket_frame_pos(10, 15, 0.5, grid, bucket)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L176-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._init_sparse_array!-Union{Tuple{T}, Tuple{I}, Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}, GridParam{I, T}}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._init_sparse_array!-Union{Tuple{T}, Tuple{I}, Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}, GridParam{I, T}}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._init_sparse_array!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_init_sparse_array!(
    sparse_array::Vector{SparseMatrixCSC{T,I}}, grid::GridParam{I,T}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function reinitializes <code>sparse_array</code>. <code>sparse_array</code> is expected to be either <code>body</code> or <code>body_soil</code>.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sparse_array::Vector{SparseMatrixCSC{Float64,Int64}}</code>: Either <code>body</code> or <code>body_soil</code>.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_init_sparse_array!(out.body, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L232-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._locate_all_non_zeros-Union{Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}}, Tuple{T}, Tuple{I}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._locate_all_non_zeros-Union{Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}}, Tuple{T}, Tuple{I}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._locate_all_non_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_locate_all_non_zeros(
    sparse_array::Vector{SparseMatrixCSC{T,I}}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function returns the indices of all non-zero values in <code>sparse_array</code>. <code>sparse_array</code> is expected to be either <code>body</code> or <code>body_soil</code>.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The first index in the returned vector corresponds to the bucket layer, while the second and third indices are the indices in the X and Y direction, respectively.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sparse_array::Vector{SparseMatrixCSC{Float64,Int64}}</code>: Either <code>body</code> or <code>body_soil</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>:: Collection of cells indices where <code>sparse_array</code> is non-zero.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

body_soil_pos = _locate_all_non_zeros(out.body_soil)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L268-L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._locate_non_zeros-Union{Tuple{SparseArrays.SparseMatrixCSC{T, I}}, Tuple{T}, Tuple{I}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._locate_non_zeros-Union{Tuple{SparseArrays.SparseMatrixCSC{T, I}}, Tuple{T}, Tuple{I}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._locate_non_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_locate_non_zeros(
    sparse_matrix::SparseMatrixCSC{T,I}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function returns the indices of all non-zero values in a sparse Matrix.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>This implementation is faster than a simple loop.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sparse_matrix::SparseMatrixCSC{Float64,Int64}</code>: Input Matrix for which non-zero values                                                  should be located.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>:: Collection of cells indices where the value of the input Matrix                           is non-zero.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

non_zeros = _locate_non_zeros(out.body[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L335-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics._write_vector-Union{Tuple{T}, Tuple{Any, T, T, T}} where T&lt;:Float64" href="#SoilDynamics._write_vector-Union{Tuple{T}, Tuple{Any, T, T, T}} where T&lt;:Float64"><code>SoilDynamics._write_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_write_vector(
    io, x::T, y::T, z::T
) where {T&lt;:Float64}</code></pre><p>This is an utility function to write a 3D vector, such as Cartesian coordinates, into a file.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>io</code>: Used as a reference to the writing file.</li><li><code>x::Float64</code>: X coordinate of the position to write.</li><li><code>y::Float64</code>: Y coordinate of the position to write.</li><li><code>z::Float64</code>: Z coordinate of the position to write.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">open(&quot;file.txt&quot;, &quot;a&quot;) do io
    write_vector(io, 0.0, 0.0, 1.0)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L846-L871">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics.calc_normal-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Float64" href="#SoilDynamics.calc_normal-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Float64"><code>SoilDynamics.calc_normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_normal(
    a::Vector{T}, b::Vector{T}, c::Vector{T}
) where {T&lt;:Float64}</code></pre><p>This function calculates the unit normal vector of a plane formed by three points using the right-hand rule.</p><p><strong>Note</strong></p><ul><li>The input order of the points is important as it determines the sign of the unit normal vector based on the right-hand rule.</li></ul><p><strong>Inputs</strong></p><ul><li><code>a::Vector{Float64}</code>: Cartesian coordinates of the first point of the plane. [m]</li><li><code>b::Vector{Float64}</code>: Cartesian coordinates of the second point of the plane. [m]</li><li><code>c::Vector{Float64}</code>: Cartesian coordinates of the third point of the plane. [m]</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Float64}</code>: Unit normal vector of the provided plane. [m]</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">a = [0.0, 0.0, 0.0]
b = [1.0, 0.5, 0.23]
c = [0.1, 0.2, -0.5]

unit_normal = calc_normal(a, b, c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L379-L406">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics.check_bucket_movement-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics.check_bucket_movement-Union{Tuple{T}, Tuple{I}, Tuple{Vector{T}, ReferenceFrameRotations.Quaternion{T}, GridParam{I, T}, BucketParam{T}}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics.check_bucket_movement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_bucket_movement(
    pos::Vector{T}, ori::Quaternion{T}, grid::GridParam{I,T}, bucket::BucketParam{T}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function calculates the maximum distance travelled by any part of the bucket since the last soil update. The position of the bucket during the last soil update is stored in the <code>BucketParam</code> struct.</p><p><strong>Note</strong></p><ul><li>If the maximum distance travelled is lower than 50% of the cell size, the function returns <code>false</code> otherwise it returns <code>true</code>.</li><li>If the distance travelled exceeds twice the cell size, a warning is issued to indicate a potential problem with the soil update.</li></ul><p><strong>Inputs</strong></p><ul><li><code>pos::Vector{Float64}</code>: Cartesian coordinates of the bucket origin. [m]</li><li><code>ori::Quaternion{Float64}</code>: Orientation of the bucket. [Quaternion]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Bool</code>: Flag indicating whether the bucket has moved enough for conducting a soil update.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">pos = [0.1, 0.0, 0.2]
ori = angle_to_quat(0.0, -pi / 2, 0.0, :ZYX)
o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)
grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)

soil_update = check_bucket_movement(pos, ori, grid, bucket)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L76-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics.check_soil-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics.check_soil-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics.check_soil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_soil(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function checks that all the simulation outputs follow the conventions of the simulator. If any inconsistency is found, a warning is issued. The conventions that are checked include:</p><ul><li>The terrain should not overlap with the bucket.</li><li>The bucket should be properly defined, with its maximum height higher than its minimum height.</li><li>The bucket soil should be properly defined, with its maximum height higher than its minimum height.</li><li>The two bucket layers should not overlap or touch each other.</li><li>One bucket layer should not overlap with all bucket soil layer.</li><li>The bucket should not overlap with the corresponding bucket soil layer.</li><li>The bucket soil layer should be resting on the corresponding bucket layer.</li><li>The bucket should be present when there is bucket soil.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Bool</code>: Whether the checks were successfull or not.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

check_soil(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L527-L560">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics.check_volume-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T, GridParam{I, T}}, Tuple{SimOut{B, I, T}, T, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics.check_volume-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T, GridParam{I, T}}, Tuple{SimOut{B, I, T}, T, GridParam{I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics.check_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_volume(
    out::SimOut{B,I,T}, init_volume::T, grid::GridParam{I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function checks that the volume of soil is conserved and that the amount of soil in <code>body_soil_pos</code> is consistent with the amount of soil in <code>body_soil</code>. The initial volume of soil (<code>init_volume</code>) has to be provided.</p><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>init_volume::Float64</code>: Initial volume of soil in the terrain. [m^3]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Bool</code>: Whether the checks were successfull or not.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)
init_volume = 0.0

check_volume(out, init_volume, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L438-L465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics.set_RNG_seed!-Union{Tuple{}, Tuple{I}} where I&lt;:Int64" href="#SoilDynamics.set_RNG_seed!-Union{Tuple{}, Tuple{I}} where I&lt;:Int64"><code>SoilDynamics.set_RNG_seed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_RNG_seed!(
    seed::I=1234
) where {I&lt;:Int64}</code></pre><p>This function sets the used RNG seed.</p><p><strong>Inputs</strong></p><ul><li><code>seed::Int64</code>: Value of the RNG seed.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">set_RNG_seed!(1234)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L415-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics.write_bucket-Union{Tuple{BucketParam{T}}, Tuple{T}} where T&lt;:Float64" href="#SoilDynamics.write_bucket-Union{Tuple{BucketParam{T}}, Tuple{T}} where T&lt;:Float64"><code>SoilDynamics.write_bucket</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_bucket(
    bucket::BucketParam{T}
) where {T&lt;:Float64}</code></pre><p>This function writes the position of all bucket faces into a csv located in the &quot;results&quot; directory. The file is named &quot;bucket&quot; followed by the file number.</p><p><strong>Inputs</strong></p><ul><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)

write_bucket(bucket)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L766-L790">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SoilDynamics.write_soil-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics.write_soil-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics.write_soil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_soil(
    out::SimOut{B,I,T}, grid::GridParam{I,T}
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function writes the terrain and the bucket soil into a csv located in the &quot;results&quot; directory. <code>terrain</code> and <code>body_soil</code> are saved into files named &quot;terrain&quot; and &quot;body_soil&quot;, respectively, followed by the file number.</p><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid

write_soil(out, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/ac2106aaee2459bbd1a013127e19c649a7db2628/src/utils.jl#L688-L712">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../relax/">« relax.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 5 May 2024 00:53">Sunday 5 May 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
