<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>utils.jl · Soil dynamics simulator</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Soil dynamics simulator</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../types/">types.jl</a></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../bucket/">bucket.jl</a></li><li><a class="tocitem" href="../body_soil/">body_soil.jl</a></li><li><a class="tocitem" href="../intersecting_cells/">intersecting_cells.jl</a></li><li><a class="tocitem" href="../relax/">relax.jl</a></li><li class="is-active"><a class="tocitem" href>utils.jl</a><ul class="internal"><li><a class="tocitem" href="#Checking-functions"><span>Checking functions</span></a></li><li><a class="tocitem" href="#Writing-functions"><span>Writing functions</span></a></li><li><a class="tocitem" href="#_locate_all_non_zeros"><span><code>_locate_all_non_zeros</code></span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>utils.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>utils.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/main/docs/src/utils.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation-for-utils.jl"><a class="docs-heading-anchor" href="#Documentation-for-utils.jl">Documentation for utils.jl</a><a id="Documentation-for-utils.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation-for-utils.jl" title="Permalink"></a></h1><p>This file aggregates a collection of utility functions. Information for some of these functions are provided below.</p><h2 id="Checking-functions"><a class="docs-heading-anchor" href="#Checking-functions">Checking functions</a><a id="Checking-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-functions" title="Permalink"></a></h2><p>This corresponds to the functions <code>check_volume</code> and <code>check_soil</code>, which can be used to check the validity of the simulation outputs. It is important to call these functions either before or after the simulation stepping process, as the outputs may be temporarily invalid during the stepping.</p><p>The <code>check_volume</code> function verifies mass conservation, ensuring that the total mass of soil is properly conserved throughout the simulation.  The <code>check_soil</code> function checks the coherence and integrity of the terrain, bucket soil, and bucket. It ensures that there are no intersections or conflicting cell assignments between these three groups.</p><p>Note that these functions are computationally intensive and may slow down the simulation. Therefore, it is recommended to use them primarily for debugging and testing purposes.</p><h2 id="Writing-functions"><a class="docs-heading-anchor" href="#Writing-functions">Writing functions</a><a id="Writing-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-functions" title="Permalink"></a></h2><p>This corresponds to the functions <code>write_soil</code> and <code>write_bucket</code>, which can be used to write the outputs into csv files. The <code>write_bucket</code> function generates files starting with <code>bucket</code>, containing the Cartesian coordinates of the four bucket walls&#39; edges. Conversely, the <code>write_soil</code> function generates files starting with <code>terrain</code> for the terrain height and <code>body_soil</code> for the bucket soil height. All the output files are saved in the <code>results</code> folder, with sequentially increasing numbers appended to the filenames.</p><p>Note that these functions are primarily designed to be used in the example script provided. Consequently, they have potential limitations that should be considered by the user. Firstly, the file numbers are assigned sequentially. If the <code>write_bucket</code> and <code>write_soil</code> functions are not called together consistently, the file numbers of the <code>bucket</code> and <code>terrain</code> may not correspond. Additionally, this may cause issues if existing files are present in the <code>results</code> folder.</p><p>Secondly, the file formats generated by these functions are specifically designed for visualization with Paraview. To visualize the data using a different tool, some change to the file formats may be needed.</p><h2 id="_locate_all_non_zeros"><a class="docs-heading-anchor" href="#_locate_all_non_zeros"><code>_locate_all_non_zeros</code></a><a id="_locate_all_non_zeros-1"></a><a class="docs-heading-anchor-permalink" href="#_locate_all_non_zeros" title="Permalink"></a></h2><p>The purpose of this function is to provide a list of indices corresponding to the non-zero elements of either the <code>body</code> or <code>body_soil</code> field of the <code>SimOut</code> struct. <code>body</code> and <code>body_soil</code> are a vector of Sparse Matrices indicating the location of the bucket and bucket soil, respectively. Sparse Matrices are used to speed up the code and reduce memory allocation, but this function is still slow and should be used only when necessary.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._init_sparse_array!-Union{Tuple{T}, Tuple{I}, Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}, GridParam{I, T}}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._init_sparse_array!-Union{Tuple{T}, Tuple{I}, Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}, GridParam{I, T}}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._init_sparse_array!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_init_sparse_array!(
    sparse_array::Vector{SparseMatrixCSC{T,I}}, grid::GridParam{I,T}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function reinitializes <code>sparse_array</code>. <code>sparse_array</code> is expected to be either <code>body</code> or <code>body_soil</code>.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sparse_array::Vector{SparseMatrixCSC{Float64,Int64}}</code>: Either <code>body</code> or <code>body_soil</code>.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

_init_sparse_array!(out.body, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L9-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._locate_all_non_zeros-Union{Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}}, Tuple{T}, Tuple{I}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._locate_all_non_zeros-Union{Tuple{Array{SparseArrays.SparseMatrixCSC{T, I}, 1}}, Tuple{T}, Tuple{I}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._locate_all_non_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_locate_all_non_zeros(
    sparse_array::Vector{SparseMatrixCSC{T,I}}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function returns the indices of all non-zero values in <code>sparse_array</code>. <code>sparse_array</code> is expected to be either <code>body</code> or <code>body_soil</code>.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>The first index in the returned vector corresponds to the bucket layer, while the second and third indices are the indices in the X and Y direction, respectively.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sparse_array::Vector{SparseMatrixCSC{Float64,Int64}}</code>: Either <code>body</code> or <code>body_soil</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>:: Collection of cells indices where <code>sparse_array</code> is non-zero.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

body_soil_pos = _locate_all_non_zeros(out.body_soil)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L46-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._locate_non_zeros-Union{Tuple{SparseArrays.SparseMatrixCSC{T, I}}, Tuple{T}, Tuple{I}} where {I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics._locate_non_zeros-Union{Tuple{SparseArrays.SparseMatrixCSC{T, I}}, Tuple{T}, Tuple{I}} where {I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics._locate_non_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_locate_non_zeros(
    sparse_matrix::SparseMatrixCSC{T,I}
) where {I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function returns the indices of all non-zero values in a sparse Matrix.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li><li>This implementation is faster than a simple loop.</li></ul><p><strong>Inputs</strong></p><ul><li><code>sparse_matrix::SparseMatrixCSC{Float64,Int64}</code>: Input Matrix for which non-zero values                                                  should be located.</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{Vector{Int64}}</code>:: Collection of cells indices where the value of the input Matrix                           is non-zero.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

non_zeros = _locate_non_zeros(out.body[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L113-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics._write_vector-Union{Tuple{T}, Tuple{Any, T, T, T}} where T&lt;:Float64" href="#SoilDynamics._write_vector-Union{Tuple{T}, Tuple{Any, T, T, T}} where T&lt;:Float64"><code>SoilDynamics._write_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_write_vector(
    io, x::T, y::T, z::T
) where {T&lt;:Float64}</code></pre><p>This is an utility function to write a 3D vector, such as Cartesian coordinates, into a file.</p><p><strong>Note</strong></p><ul><li>This function is intended for internal use only.</li></ul><p><strong>Inputs</strong></p><ul><li><code>io</code>: Used as a reference to the writing file.</li><li><code>x::Float64</code>: X coordinate of the position to write.</li><li><code>y::Float64</code>: Y coordinate of the position to write.</li><li><code>z::Float64</code>: Z coordinate of the position to write.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">open(&quot;file.txt&quot;, &quot;a&quot;) do io
    write_vector(io, 0.0, 0.0, 1.0)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L587-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics.calc_normal-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Float64" href="#SoilDynamics.calc_normal-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Vector{T}}} where T&lt;:Float64"><code>SoilDynamics.calc_normal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calc_normal(
    a::Vector{T}, b::Vector{T}, c::Vector{T}
) where {T&lt;:Float64}</code></pre><p>This function calculates the unit normal vector of a plane formed by three points using the right-hand rule.</p><p><strong>Note</strong></p><ul><li>The input order of the points is important as it determines the sign of the unit normal vector based on the right-hand rule.</li></ul><p><strong>Inputs</strong></p><ul><li><code>a::Vector{Float64}</code>: Cartesian coordinates of the first point of the plane. [m]</li><li><code>b::Vector{Float64}</code>: Cartesian coordinates of the second point of the plane. [m]</li><li><code>c::Vector{Float64}</code>: Cartesian coordinates of the third point of the plane. [m]</li></ul><p><strong>Outputs</strong></p><ul><li><code>Vector{T}</code>: Unit normal vector of the provided plane. [m]</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">a = [0.0, 0.0, 0.0]
b = [1.0, 0.5, 0.23]
c = [0.1, 0.2, -0.5]

unit_normal = calc_normal(a, b, c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L157-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics.check_soil-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics.check_soil-Union{Tuple{SimOut{B, I, T}}, Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics.check_soil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_soil(
    out::SimOut{B,I,T}, tol::T=1e-8
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function checks that all the simulation outputs follow the conventions of the simulator. If any inconsistency is found, a warning is issued. The conventions that are checked include:</p><ul><li>The terrain should not overlap with the bucket.</li><li>The bucket should be properly defined, with its maximum height higher than its minimum height.</li><li>The bucket soil should be properly defined, with its maximum height higher than its minimum height.</li><li>The two bucket layers should not overlap or touch each other.</li><li>One bucket layer should not overlap with all bucket soil layer.</li><li>The bucket should not overlap with the corresponding bucket soil layer.</li><li>The bucket soil layer should be resting on the corresponding bucket layer.</li><li>The bucket should be present when there is bucket soil.</li></ul><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>tol::Float64</code>: Small number used to handle numerical approximation errors.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)

check_soil(out)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L277-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics.check_volume-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T, GridParam{I, T}}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics.check_volume-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, T, GridParam{I, T}}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics.check_volume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_volume(
    out::SimOut{B,I,T}, init_volume::T, grid::GridParam{I,T}
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function checks that the volume of soil is conserved. The initial volume of soil (<code>init_volume</code>) has to be provided.</p><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>init_volume::Float64</code>: Initial volume of soil in the terrain. [m^3]</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid)
init_volume = 0.0

check_volume(out, init_volume, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L218-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics.set_RNG_seed!-Union{Tuple{}, Tuple{I}} where I&lt;:Int64" href="#SoilDynamics.set_RNG_seed!-Union{Tuple{}, Tuple{I}} where I&lt;:Int64"><code>SoilDynamics.set_RNG_seed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_RNG_seed!(
    seed::I=1234
) where {I&lt;:Int64}</code></pre><p>This function sets the used RNG seed.</p><p><strong>Inputs</strong></p><ul><li><code>seed::Int64</code>: Value of the RNG seed.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">set_RNG_seed!(1234)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L194-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics.write_bucket-Union{Tuple{BucketParam{T}}, Tuple{T}} where T&lt;:Float64" href="#SoilDynamics.write_bucket-Union{Tuple{BucketParam{T}}, Tuple{T}} where T&lt;:Float64"><code>SoilDynamics.write_bucket</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_bucket(
    bucket::BucketParam{T}
) where {T&lt;:Float64}</code></pre><p>This function writes the position of all bucket faces into a csv located in the &quot;results&quot; directory. The file is named &quot;bucket&quot; followed by the file number.</p><p><strong>Inputs</strong></p><ul><li><code>bucket::BucketParam{Float64}</code>: Struct that stores information related to the                                 bucket object.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">o = [0.0, 0.0, 0.0]
j = [0.0, 0.0, 0.0]
b = [0.0, 0.0, -0.5]
t = [1.0, 0.0, -0.5]
bucket = BucketParam(o, j, b, t, 0.5)

write_bucket(bucket)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L507-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SoilDynamics.write_soil-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}" href="#SoilDynamics.write_soil-Union{Tuple{T}, Tuple{I}, Tuple{B}, Tuple{SimOut{B, I, T}, GridParam{I, T}}} where {B&lt;:Bool, I&lt;:Int64, T&lt;:Float64}"><code>SoilDynamics.write_soil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_soil(
    out::SimOut{B,I,T}, grid::GridParam{I,T}
) where {B&lt;:Bool,I&lt;:Int64,T&lt;:Float64}</code></pre><p>This function writes the terrain and the bucket soil into a csv located in the &quot;results&quot; directory. <code>terrain</code> and <code>body_soil</code> are saved into files named &quot;terrain&quot; and &quot;body_soil&quot;, respectively, followed by the file number.</p><p><strong>Inputs</strong></p><ul><li><code>out::SimOut{Bool,Int64,Float64}</code>: Struct that stores simulation outputs.</li><li><code>grid::GridParam{Int64,Float64}</code>: Struct that stores information related to the                                   simulation grid.</li></ul><p><strong>Outputs</strong></p><ul><li>None</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">grid = GridParam(4.0, 4.0, 3.0, 0.05, 0.01)
terrain = zeros(2 * grid.half_length_x + 1, 2 * grid.half_length_y + 1)
out = SimOut(terrain, grid

write_soil(out, grid)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/KennyVilella/soil_dynamics_julia/blob/5a7b07d52309198d6f9918e674065fb23803ff6f/src/utils.jl#L429-L453">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../relax/">« relax.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 30 July 2023 02:18">Sunday 30 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
